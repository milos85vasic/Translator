
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>distributed: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">digital.vasic.translator/pkg/distributed/coordinator.go (42.5%)</option>
				
				<option value="file1">digital.vasic.translator/pkg/distributed/fallback.go (85.7%)</option>
				
				<option value="file2">digital.vasic.translator/pkg/distributed/manager.go (72.0%)</option>
				
				<option value="file3">digital.vasic.translator/pkg/distributed/pairing.go (40.2%)</option>
				
				<option value="file4">digital.vasic.translator/pkg/distributed/performance.go (69.7%)</option>
				
				<option value="file5">digital.vasic.translator/pkg/distributed/performance_test_extended.go (0.0%)</option>
				
				<option value="file6">digital.vasic.translator/pkg/distributed/security.go (61.7%)</option>
				
				<option value="file7">digital.vasic.translator/pkg/distributed/ssh_pool.go (50.4%)</option>
				
				<option value="file8">digital.vasic.translator/pkg/distributed/version_manager.go (26.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package distributed

import (
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync"
        "time"

        "digital.vasic.translator/pkg/deployment"
        "digital.vasic.translator/pkg/events"
        "digital.vasic.translator/pkg/translator"
        "digital.vasic.translator/pkg/translator/llm"
)

// RemoteLLMInstance represents a remote LLM instance
type RemoteLLMInstance struct {
        ID        string
        WorkerID  string
        Provider  string
        Model     string
        Priority  int
        Available bool
        LastUsed  time.Time
        mu        sync.Mutex
}

// DistributedCoordinator manages distributed LLM instances across remote workers
type DistributedCoordinator struct {
        localCoordinator interface{} // Will be *coordination.MultiLLMCoordinator
        remoteInstances  []*RemoteLLMInstance
        sshPool          *SSHPool
        pairingManager   *PairingManager
        fallbackManager  *FallbackManager
        versionManager   *VersionManager
        eventBus         *events.EventBus
        apiLogger        *deployment.APICommunicationLogger
        currentIndex     int
        maxRetries       int
        retryDelay       time.Duration
        mu               sync.RWMutex
}

// NewDistributedCoordinator creates a new distributed coordinator
func NewDistributedCoordinator(
        localCoordinator interface{},
        sshPool *SSHPool,
        pairingManager *PairingManager,
        fallbackManager *FallbackManager,
        versionManager *VersionManager,
        eventBus *events.EventBus,
        apiLogger *deployment.APICommunicationLogger,
) *DistributedCoordinator <span class="cov10" title="64">{
        return &amp;DistributedCoordinator{
                localCoordinator: localCoordinator,
                remoteInstances:  make([]*RemoteLLMInstance, 0),
                sshPool:          sshPool,
                pairingManager:   pairingManager,
                fallbackManager:  fallbackManager,
                versionManager:   versionManager,
                eventBus:         eventBus,
                apiLogger:        apiLogger,
                currentIndex:     0,
                maxRetries:       3,
                retryDelay:       2 * time.Second,
        }
}</span>

// DiscoverRemoteInstances discovers LLM instances on paired remote workers
func (dc *DistributedCoordinator) DiscoverRemoteInstances(ctx context.Context) error <span class="cov1" title="1">{
        pairedServices := dc.pairingManager.GetPairedServices()

        dc.mu.Lock()
        defer dc.mu.Unlock()

        // Clear existing remote instances
        dc.remoteInstances = make([]*RemoteLLMInstance, 0)

        instanceID := 1
        for workerID, service := range pairedServices </span><span class="cov0" title="0">{
                // Query remote service for available providers
                providers, err := dc.queryRemoteProviders(ctx, service)
                if err != nil </span><span class="cov0" title="0">{
                        dc.emitWarning(fmt.Sprintf("Failed to query providers from worker %s: %v", workerID, err))
                        continue</span>
                }

                // Create instances based on provider capabilities
                <span class="cov0" title="0">for provider, config := range providers </span><span class="cov0" title="0">{
                        // Determine priority based on provider type
                        priority := dc.getPriorityForProvider(provider)

                        // Get first model from models array, or use provider name as fallback
                        model := provider // default
                        if models, ok := config["models"].([]interface{}); ok &amp;&amp; len(models) &gt; 0 </span><span class="cov0" title="0">{
                                if firstModel, ok := models[0].(string); ok </span><span class="cov0" title="0">{
                                        model = firstModel
                                }</span>
                        }

                        // Create multiple instances based on priority
                        <span class="cov0" title="0">instanceCount := dc.getInstanceCountForPriority(priority, service.Capabilities.MaxConcurrent)

                        for i := 0; i &lt; instanceCount; i++ </span><span class="cov0" title="0">{
                                instance := &amp;RemoteLLMInstance{
                                        ID:        fmt.Sprintf("remote-%s-%d", provider, instanceID),
                                        WorkerID:  workerID,
                                        Provider:  provider,
                                        Model:     model,
                                        Priority:  priority,
                                        Available: true,
                                        LastUsed:  time.Time{},
                                }

                                dc.remoteInstances = append(dc.remoteInstances, instance)
                                instanceID++
                        }</span>
                }
        }

        <span class="cov0" title="0">dc.emitEvent(events.Event{
                Type:      "distributed_instances_discovered",
                SessionID: "system",
                Message:   fmt.Sprintf("Discovered %d remote LLM instances across %d workers", len(dc.remoteInstances), len(pairedServices)),
                Data: map[string]interface{}{
                        "remote_instances": len(dc.remoteInstances),
                        "workers":          len(pairedServices),
                },
        })

        return nil</span>
}

// queryRemoteProviders queries a remote service for available providers
func (dc *DistributedCoordinator) queryRemoteProviders(ctx context.Context, service *RemoteService) (map[string]map[string]interface{}, error) <span class="cov1" title="1">{
        url := fmt.Sprintf("%s://%s:%d/api/v1/providers", service.Protocol, service.Host, service.Port)

        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Log outgoing request if logger is available
        <span class="cov1" title="1">var logEntry *deployment.APICommunicationLog
        if dc.apiLogger != nil </span><span class="cov1" title="1">{
                logEntry = dc.apiLogger.LogRequest(service.Host, 8443, service.Host, service.Port, "GET", "/api/v1/providers", 0)
        }</span>

        // Use HTTP client that accepts self-signed certificates
        <span class="cov1" title="1">client := &amp;http.Client{
                Timeout: 30 * time.Second,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                InsecureSkipVerify: true,
                        },
                },
        }

        startTime := time.Now()
        resp, err := client.Do(req)
        duration := time.Since(startTime)

        if err != nil </span><span class="cov1" title="1">{
                // Log failed response if logger is available
                if dc.apiLogger != nil &amp;&amp; logEntry != nil </span><span class="cov1" title="1">{
                        dc.apiLogger.LogResponse(logEntry, 0, 0, duration, err)
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                // Log failed response if logger is available
                if dc.apiLogger != nil &amp;&amp; logEntry != nil </span><span class="cov0" title="0">{
                        dc.apiLogger.LogResponse(logEntry, resp.StatusCode, 0, duration, err)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Log successful response if logger is available
        <span class="cov0" title="0">if dc.apiLogger != nil &amp;&amp; logEntry != nil </span><span class="cov0" title="0">{
                dc.apiLogger.LogResponse(logEntry, resp.StatusCode, int64(len(body)), duration, nil)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var response map[string]interface{}
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">providers := make(map[string]map[string]interface{})

        // Extract providers from response - handle both array and map formats
        if providersList, ok := response["providers"].([]interface{}); ok </span><span class="cov0" title="0">{
                // Array format: [{"name": "ollama", "models": [...], ...}, ...]
                for _, item := range providersList </span><span class="cov0" title="0">{
                        if providerMap, ok := item.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if name, ok := providerMap["name"].(string); ok </span><span class="cov0" title="0">{
                                        providers[name] = providerMap
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> if providersMap, ok := response["providers"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Map format: {"ollama": {...}, ...}
                for provider, config := range providersMap </span><span class="cov0" title="0">{
                        if configMap, ok := config.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                providers[provider] = configMap
                        }</span>
                }
        }

        <span class="cov0" title="0">return providers, nil</span>
}

// getPriorityForProvider determines priority based on provider type
func (dc *DistributedCoordinator) getPriorityForProvider(provider string) int <span class="cov5" title="7">{
        switch provider </span>{
        case "openai", "anthropic", "zhipu", "deepseek":<span class="cov4" title="4">
                return 10</span> // API key providers - highest priority
        case "ollama", "llamacpp":<span class="cov2" title="2">
                return 5</span> // Local LLM providers - medium priority
        default:<span class="cov1" title="1">
                return 1</span> // Default priority
        }
}

// getInstanceCountForPriority determines how many instances to create based on priority and max concurrent
func (dc *DistributedCoordinator) getInstanceCountForPriority(priority int, maxConcurrent int) int <span class="cov4" title="4">{
        baseCount := 1

        switch </span>{
        case priority &gt;= 10:<span class="cov2" title="2"> // API key providers
                baseCount = 3</span>
        case priority &gt;= 5:<span class="cov1" title="1"> // OAuth providers
                baseCount = 2</span>
        default:<span class="cov1" title="1"> // Free/local providers
                baseCount = 1</span>
        }

        // Don't exceed max concurrent capacity
        <span class="cov4" title="4">if baseCount &gt; maxConcurrent </span><span class="cov1" title="1">{
                baseCount = maxConcurrent
        }</span>

        <span class="cov4" title="4">return baseCount</span>
}

// TranslateWithDistributedRetry translates using distributed instances with comprehensive fallback
func (dc *DistributedCoordinator) TranslateWithDistributedRetry(
        ctx context.Context,
        text string,
        contextHint string,
) (string, error) <span class="cov1" title="1">{

        var result string
        var resultMu sync.Mutex

        // Define fallback strategies
        fallbacks := []FallbackStrategy{
                {
                        Name: "remote_instances",
                        Function: func() error </span><span class="cov4" title="4">{
                                translated, err := dc.translateWithRemoteInstances(ctx, text, contextHint)
                                if err != nil </span><span class="cov4" title="4">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">resultMu.Lock()
                                result = translated
                                resultMu.Unlock()
                                return nil</span>
                        },
                        Priority: 1,
                },
                {
                        Name: "local_coordinator",
                        Function: func() error <span class="cov4" title="4">{
                                // Use local translation as fallback
                                // Create a simple local translator using available providers
                                config := translator.TranslationConfig{
                                        SourceLang: "auto",
                                        TargetLang: "en", // Default to English for fallback
                                        Provider:   "openai",
                                        Model:      "gpt-3.5-turbo",
                                }

                                localTranslator, err := llm.NewLLMTranslator(config)
                                if err != nil </span><span class="cov4" title="4">{
                                        // Try with a different provider
                                        config.Provider = "anthropic"
                                        config.Model = "claude-3-haiku-20240307"
                                        localTranslator, err = llm.NewLLMTranslator(config)
                                        if err != nil </span><span class="cov4" title="4">{
                                                return fmt.Errorf("failed to create local fallback translator: %w", err)
                                        }</span>
                                }

                                <span class="cov0" title="0">translated, err := localTranslator.Translate(ctx, text, contextHint)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("local fallback translation failed: %w", err)
                                }</span>

                                <span class="cov0" title="0">resultMu.Lock()
                                result = translated
                                resultMu.Unlock()
                                return nil</span>
                        },
                        Priority: 2,
                },
                {
                        Name: "reduced_quality",
                        Function: func() error <span class="cov1" title="1">{
                                // Implement reduced quality fallback using basic word replacement
                                // This is a very simple translation for emergency fallback
                                fallbackTranslations := map[string]string{
                                        "hello":     "hola",
                                        "goodbye":   "adiós",
                                        "thank you": "gracias",
                                        "please":    "por favor",
                                        "sorry":     "lo siento",
                                        "yes":       "sí",
                                        "no":        "no",
                                        "good":      "bueno",
                                        "bad":       "malo",
                                        "big":       "grande",
                                        "small":     "pequeño",
                                        "hot":       "caliente",
                                        "cold":      "frío",
                                        "day":       "día",
                                        "night":     "noche",
                                        "water":     "agua",
                                        "food":      "comida",
                                        "house":     "casa",
                                        "car":       "coche",
                                        "book":      "libro",
                                        "computer":  "computadora",
                                }

                                // Simple word-by-word replacement
                                words := strings.Fields(strings.ToLower(text))
                                var translatedWords []string

                                for _, word := range words </span><span class="cov2" title="2">{
                                        if translation, exists := fallbackTranslations[word]; exists </span><span class="cov1" title="1">{
                                                translatedWords = append(translatedWords, translation)
                                        }</span> else<span class="cov1" title="1"> {
                                                // Keep original word if no translation available
                                                translatedWords = append(translatedWords, word)
                                        }</span>
                                }

                                <span class="cov1" title="1">result := strings.Join(translatedWords, " ")

                                resultMu.Lock()
                                result = result
                                resultMu.Unlock()
                                return nil</span>
                        },
                        Priority: 3,
                },
        }

        // Use FallbackManager for comprehensive fallback handling
        <span class="cov1" title="1">componentID := "distributed_translator"
        err := dc.fallbackManager.ExecuteWithFallback(ctx, componentID, func() error </span><span class="cov4" title="4">{
                translated, err := dc.translateWithRemoteInstances(ctx, text, contextHint)
                if err != nil </span><span class="cov4" title="4">{
                        return err
                }</span>
                <span class="cov0" title="0">resultMu.Lock()
                result = translated
                resultMu.Unlock()
                return nil</span>
        }, fallbacks...)

        <span class="cov1" title="1">resultMu.Lock()
        finalResult := result
        resultMu.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">return finalResult, nil</span>
}

// translateWithRemoteInstances attempts translation using remote instances
func (dc *DistributedCoordinator) translateWithRemoteInstances(
        ctx context.Context,
        text string,
        contextHint string,
) (string, error) <span class="cov5" title="9">{

        if len(dc.remoteInstances) == 0 </span><span class="cov5" title="9">{
                return "", fmt.Errorf("no remote instances available")
        }</span>

        <span class="cov0" title="0">var lastErr error
        triedInstances := make(map[string]bool)

        for attempt := 0; attempt &lt; dc.maxRetries*len(dc.remoteInstances); attempt++ </span><span class="cov0" title="0">{
                instance := dc.getNextRemoteInstance()
                if instance == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if triedInstances[instance.ID] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">triedInstances[instance.ID] = true

                // Validate worker version before attempting translation
                if err := dc.validateWorkerForWork(ctx, instance.WorkerID); err != nil </span><span class="cov0" title="0">{
                        dc.emitWarning(fmt.Sprintf("Worker %s validation failed: %v", instance.WorkerID, err))
                        continue</span>
                }

                <span class="cov0" title="0">dc.emitEvent(events.Event{
                        Type:      "distributed_translation_attempt",
                        SessionID: "system",
                        Message:   fmt.Sprintf("Attempting distributed translation with %s on worker %s", instance.ID, instance.WorkerID),
                        Data: map[string]interface{}{
                                "instance_id": instance.ID,
                                "worker_id":   instance.WorkerID,
                                "provider":    instance.Provider,
                                "attempt":     attempt + 1,
                        },
                })

                result, err := dc.translateWithRemoteInstance(ctx, instance, text, contextHint)
                if err == nil &amp;&amp; result != "" </span><span class="cov0" title="0">{
                        instance.LastUsed = time.Now()
                        dc.emitEvent(events.Event{
                                Type:      "distributed_translation_success",
                                SessionID: "system",
                                Message:   fmt.Sprintf("Distributed translation successful with %s", instance.ID),
                                Data: map[string]interface{}{
                                        "instance_id": instance.ID,
                                        "worker_id":   instance.WorkerID,
                                },
                        })
                        return result, nil
                }</span>

                <span class="cov0" title="0">lastErr = err
                dc.emitWarning(fmt.Sprintf("Distributed translation attempt %d failed: %v", attempt+1, err))</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("all distributed translation attempts failed, last error: %w", lastErr)</span>
}

// validateWorkerForWork validates that a worker is ready for work
func (dc *DistributedCoordinator) validateWorkerForWork(ctx context.Context, workerID string) error <span class="cov1" title="1">{
        if dc.versionManager == nil </span><span class="cov1" title="1">{
                // Version manager not available, skip validation
                return nil
        }</span>

        // Get the service for this worker
        <span class="cov0" title="0">services := dc.pairingManager.GetPairedServices()
        service, exists := services[workerID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("worker %s not found in paired services", workerID)
        }</span>

        // Validate worker version and health
        <span class="cov0" title="0">return dc.versionManager.ValidateWorkerForWork(ctx, service)</span>
}

// getNextRemoteInstance returns the next remote instance in round-robin fashion
func (dc *DistributedCoordinator) getNextRemoteInstance() *RemoteLLMInstance <span class="cov4" title="5">{
        dc.mu.Lock()
        defer dc.mu.Unlock()

        if len(dc.remoteInstances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Use round-robin selection
        <span class="cov4" title="4">instance := dc.remoteInstances[dc.currentIndex]
        dc.currentIndex = (dc.currentIndex + 1) % len(dc.remoteInstances)

        return instance</span>
}

// translateWithRemoteInstance performs translation using a specific remote instance
func (dc *DistributedCoordinator) translateWithRemoteInstance(
        ctx context.Context,
        instance *RemoteLLMInstance,
        text string,
        contextHint string,
) (string, error) <span class="cov1" title="1">{
        // Get the service for this worker
        services := dc.pairingManager.GetPairedServices()
        service, exists := services[instance.WorkerID]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("service not found for worker %s", instance.WorkerID)
        }</span>

        // Prepare translation request
        <span class="cov0" title="0">translateURL := fmt.Sprintf("%s://%s:%d/api/v1/translate", service.Protocol, service.Host, service.Port)

        requestBody := map[string]interface{}{
                "text":         text,
                "context_hint": contextHint,
                "provider":     instance.Provider,
                "model":        instance.Model,
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", translateURL, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        // Log outgoing request
        var logEntry *deployment.APICommunicationLog
        if dc.apiLogger != nil </span><span class="cov0" title="0">{
                logEntry = dc.apiLogger.LogRequest(service.Host, 8443, service.Host, service.Port, "POST", "/api/v1/translate", int64(len(jsonData)))
        }</span>

        // Use HTTP client that accepts self-signed certificates
        <span class="cov0" title="0">client := &amp;http.Client{
                Timeout: 60 * time.Second,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                InsecureSkipVerify: true,
                        },
                },
        }

        startTime := time.Now()
        resp, err := client.Do(req)
        duration := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                // Log failed response
                if dc.apiLogger != nil &amp;&amp; logEntry != nil </span><span class="cov0" title="0">{
                        dc.apiLogger.LogResponse(logEntry, 0, 0, duration, err)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("translation request failed: %w", err)</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                // Log failed response
                if dc.apiLogger != nil &amp;&amp; logEntry != nil </span><span class="cov0" title="0">{
                        dc.apiLogger.LogResponse(logEntry, resp.StatusCode, 0, duration, err)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to read response: %w", err)</span>
        }

        // Log successful response
        <span class="cov0" title="0">if dc.apiLogger != nil &amp;&amp; logEntry != nil </span><span class="cov0" title="0">{
                dc.apiLogger.LogResponse(logEntry, resp.StatusCode, int64(len(body)), duration, nil)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("translation failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Parse response
        <span class="cov0" title="0">var response map[string]interface{}
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse response: %w", err)
        }</span>

        // Extract translated text
        <span class="cov0" title="0">translated, ok := response["translated_text"].(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid response format: missing translated_text")
        }</span>

        <span class="cov0" title="0">return translated, nil</span>
}

// GetRemoteInstanceCount returns the number of remote instances
func (dc *DistributedCoordinator) GetRemoteInstanceCount() int <span class="cov4" title="4">{
        dc.mu.RLock()
        defer dc.mu.RUnlock()
        return len(dc.remoteInstances)
}</span>

// emitEvent emits an event if event bus is available
func (dc *DistributedCoordinator) emitEvent(event events.Event) <span class="cov1" title="1">{
        if dc.eventBus != nil </span><span class="cov1" title="1">{
                dc.eventBus.Publish(event)
        }</span>
}

// emitWarning emits a warning event
func (dc *DistributedCoordinator) emitWarning(message string) <span class="cov1" title="1">{
        if dc.eventBus != nil </span><span class="cov1" title="1">{
                dc.eventBus.Publish(events.Event{
                        Type:      "distributed_warning",
                        SessionID: "system",
                        Message:   message,
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package distributed

import (
        "context"
        "fmt"
        "sync"
        "time"

        "digital.vasic.translator/pkg/events"
)

// FallbackConfig holds fallback and recovery configuration
type FallbackConfig struct {
        // Graceful Degradation
        EnableGracefulDegradation bool
        DegradationThreshold      float64 // Percentage of failed requests before degrading

        // Retry Configuration
        MaxRetries       int
        RetryBackoffBase time.Duration
        RetryBackoffMax  time.Duration
        RetryJitter      bool

        // Timeout Configuration
        RequestTimeout     time.Duration
        ConnectionTimeout  time.Duration
        HealthCheckTimeout time.Duration

        // Recovery Configuration
        RecoveryCheckInterval    time.Duration
        RecoverySuccessThreshold int
        RecoveryWindow           time.Duration

        // Fallback Strategies
        EnableLocalFallback   bool
        EnableReducedQuality  bool
        EnableCachingFallback bool

        // Monitoring
        FailureTrackingWindow time.Duration
        AlertThreshold        float64
}

// DefaultFallbackConfig returns secure default fallback configuration
func DefaultFallbackConfig() *FallbackConfig <span class="cov10" title="63">{
        return &amp;FallbackConfig{
                EnableGracefulDegradation: true,
                DegradationThreshold:      0.5, // 50% failure rate triggers degradation
                MaxRetries:                3,
                RetryBackoffBase:          100 * time.Millisecond,
                RetryBackoffMax:           30 * time.Second,
                RetryJitter:               true,
                RequestTimeout:            30 * time.Second,
                ConnectionTimeout:         10 * time.Second,
                HealthCheckTimeout:        5 * time.Second,
                RecoveryCheckInterval:     10 * time.Second,
                RecoverySuccessThreshold:  3,
                RecoveryWindow:            60 * time.Second,
                EnableLocalFallback:       true,
                EnableReducedQuality:      true,
                EnableCachingFallback:     true,
                FailureTrackingWindow:     5 * time.Minute,
                AlertThreshold:            0.8, // 80% failure rate triggers alerts
        }
}</span>

// FallbackManager manages fallback and recovery strategies
type FallbackManager struct {
        config      *FallbackConfig
        performance *PerformanceConfig
        eventBus    EventBusInterface
        logger      Logger

        // State tracking
        failureCounts map[string]*FailureTracker
        recoveryState map[string]*RecoveryTracker
        degradedMode  bool

        mu sync.RWMutex
}

// FailureTracker tracks failures for a component
type FailureTracker struct {
        ComponentID   string
        Failures      int
        TotalRequests int
        LastFailure   time.Time
        WindowStart   time.Time
        mu            sync.Mutex
}

// RecoveryTracker tracks recovery progress
type RecoveryTracker struct {
        ComponentID          string
        ConsecutiveSuccesses int
        LastSuccess          time.Time
        InRecovery           bool
        mu                   sync.Mutex
}

// NewFallbackManager creates a new fallback manager
func NewFallbackManager(config *FallbackConfig, performance *PerformanceConfig, eventBus EventBusInterface, logger Logger) *FallbackManager <span class="cov9" title="62">{
        fm := &amp;FallbackManager{
                config:        config,
                performance:   performance,
                eventBus:      eventBus,
                logger:        logger,
                failureCounts: make(map[string]*FailureTracker),
                recoveryState: make(map[string]*RecoveryTracker),
                degradedMode:  false,
        }

        // Only start monitoring goroutines if not in test environment
        // In tests, goroutines would cause issues with zero intervals
        if config != nil &amp;&amp; config.RecoveryCheckInterval &gt; 0 </span><span class="cov9" title="52">{
                go fm.monitorFailures()
                go fm.monitorRecovery()
        }</span>

        <span class="cov9" title="62">return fm</span>
}

// ExecuteWithFallback executes a function with comprehensive fallback strategies
func (fm *FallbackManager) ExecuteWithFallback(ctx context.Context, componentID string, operation func() error, fallbacks ...FallbackStrategy) error <span class="cov7" title="20">{
        // Track the operation
        startTime := time.Now()
        defer fm.trackOperation(componentID, startTime)

        // Try primary operation with retries
        err := fm.executeWithRetries(ctx, operation)
        if err == nil </span><span class="cov4" title="4">{
                fm.recordSuccess(componentID)
                return nil
        }</span>

        <span class="cov7" title="16">fm.recordFailure(componentID, err)

        // Try fallback strategies
        for _, fallback := range fallbacks </span><span class="cov4" title="5">{
                if fm.shouldExecuteFallback(fallback) </span><span class="cov4" title="5">{
                        fm.logger.Log("info", "Executing fallback strategy", map[string]interface{}{
                                "component_id": componentID,
                                "strategy":     fallback.Name,
                                "error":        err.Error(),
                        })

                        fallbackErr := fm.executeWithRetries(ctx, fallback.Function)
                        if fallbackErr == nil </span><span class="cov2" title="2">{
                                fm.emitEvent(events.Event{
                                        Type:      "distributed_fallback_success",
                                        SessionID: "system",
                                        Message:   fmt.Sprintf("Fallback strategy '%s' succeeded for %s", fallback.Name, componentID),
                                        Data: map[string]interface{}{
                                                "component_id": componentID,
                                                "strategy":     fallback.Name,
                                                "duration":     time.Since(startTime),
                                        },
                                })
                                return nil
                        }</span>

                        <span class="cov3" title="3">fm.logger.Log("warning", "Fallback strategy failed", map[string]interface{}{
                                "component_id": componentID,
                                "strategy":     fallback.Name,
                                "error":        fallbackErr.Error(),
                        })</span>
                }
        }

        // All strategies failed
        <span class="cov6" title="14">fm.emitEvent(events.Event{
                Type:      "distributed_all_fallbacks_failed",
                SessionID: "system",
                Message:   fmt.Sprintf("All fallback strategies failed for %s", componentID),
                Data: map[string]interface{}{
                        "component_id": componentID,
                        "error":        err.Error(),
                        "duration":     time.Since(startTime),
                },
        })

        return fmt.Errorf("all operations and fallbacks failed for %s: %w", componentID, err)</span>
}

// FallbackStrategy represents a fallback strategy
type FallbackStrategy struct {
        Name     string
        Function func() error
        Priority int // Lower number = higher priority
}

// executeWithRetries executes a function with retry logic
func (fm *FallbackManager) executeWithRetries(ctx context.Context, operation func() error) error <span class="cov7" title="25">{
        var lastErr error

        for attempt := 0; attempt &lt;= fm.config.MaxRetries; attempt++ </span><span class="cov9" title="48">{
                // Check if context is cancelled
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return ctx.Err()</span>
                default:<span class="cov9" title="47"></span>
                }

                // Execute operation with timeout
                <span class="cov9" title="47">opCtx, cancel := context.WithTimeout(ctx, fm.config.RequestTimeout)

                done := make(chan error, 1)
                go func() </span><span class="cov9" title="47">{
                        done &lt;- operation()
                }</span>()

                <span class="cov9" title="47">select </span>{
                case err := &lt;-done:<span class="cov9" title="47">
                        cancel()
                        if err == nil </span><span class="cov4" title="6">{
                                return nil
                        }</span>
                        <span class="cov9" title="41">lastErr = err</span>

                case &lt;-opCtx.Done():<span class="cov0" title="0">
                        cancel()
                        lastErr = opCtx.Err()</span>
                }

                // Don't retry on context cancellation
                <span class="cov9" title="41">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>

                // Calculate backoff delay
                <span class="cov9" title="41">if attempt &lt; fm.config.MaxRetries </span><span class="cov7" title="23">{
                        delay := fm.calculateBackoff(attempt)
                        select </span>{
                        case &lt;-time.After(delay):<span class="cov7" title="23"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }
                }
        }

        <span class="cov7" title="18">return lastErr</span>
}

// calculateBackoff calculates exponential backoff delay
func (fm *FallbackManager) calculateBackoff(attempt int) time.Duration <span class="cov8" title="28">{
        delay := time.Duration(attempt+1) * fm.config.RetryBackoffBase

        // Apply exponential backoff
        if attempt &gt; 0 </span><span class="cov7" title="19">{
                multiplier := 1
                for i := 0; i &lt; attempt-1; i++ </span><span class="cov7" title="19">{
                        multiplier *= 2
                }</span>
                <span class="cov7" title="19">delay = time.Duration(float64(delay) * float64(multiplier))</span>
        }

        // Cap at maximum
        <span class="cov8" title="28">if delay &gt; fm.config.RetryBackoffMax </span><span class="cov1" title="1">{
                delay = fm.config.RetryBackoffMax
        }</span>

        // Add jitter if enabled
        <span class="cov8" title="28">if fm.config.RetryJitter </span><span class="cov7" title="21">{
                delay = time.Duration(float64(delay) * (0.5 + 0.5*float64(time.Now().UnixNano()%1000)/1000))
        }</span>

        <span class="cov8" title="28">return delay</span>
}

// shouldExecuteFallback determines if a fallback should be executed
func (fm *FallbackManager) shouldExecuteFallback(fallback FallbackStrategy) bool <span class="cov6" title="11">{
        fm.mu.RLock()
        defer fm.mu.RUnlock()

        // In degraded mode, execute all fallbacks
        if fm.degradedMode </span><span class="cov4" title="6">{
                return true
        }</span>

        // Check if fallback is enabled in config
        <span class="cov4" title="5">switch fallback.Name </span>{
        case "local_fallback":<span class="cov2" title="2">
                return fm.config.EnableLocalFallback</span>
        case "reduced_quality":<span class="cov1" title="1">
                return fm.config.EnableReducedQuality</span>
        case "caching_fallback":<span class="cov1" title="1">
                return fm.config.EnableCachingFallback</span>
        default:<span class="cov1" title="1">
                return true</span> // Execute custom fallbacks
        }
}

// recordSuccess records a successful operation
func (fm *FallbackManager) recordSuccess(componentID string) <span class="cov4" title="4">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        // Update failure tracker
        tracker, exists := fm.failureCounts[componentID]
        if !exists </span><span class="cov3" title="3">{
                tracker = &amp;FailureTracker{
                        ComponentID: componentID,
                        WindowStart: time.Now(),
                }
                fm.failureCounts[componentID] = tracker
        }</span>
        
        <span class="cov4" title="4">tracker.mu.Lock()
        tracker.TotalRequests++
        tracker.mu.Unlock()

        // Update recovery tracker
        recoveryTracker, exists := fm.recoveryState[componentID]
        if !exists </span><span class="cov3" title="3">{
                recoveryTracker = &amp;RecoveryTracker{
                        ComponentID: componentID,
                }
                fm.recoveryState[componentID] = recoveryTracker
        }</span>

        <span class="cov4" title="4">recoveryTracker.mu.Lock()
        recoveryTracker.ConsecutiveSuccesses++
        recoveryTracker.LastSuccess = time.Now()
        if recoveryTracker.ConsecutiveSuccesses &gt;= fm.config.RecoverySuccessThreshold </span><span class="cov3" title="3">{
                recoveryTracker.InRecovery = false
        }</span>
        <span class="cov4" title="4">recoveryTracker.mu.Unlock()</span>
}

// recordFailure records a failed operation
func (fm *FallbackManager) recordFailure(componentID string, err error) <span class="cov7" title="16">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        // Update failure tracker
        tracker, exists := fm.failureCounts[componentID]
        if !exists </span><span class="cov5" title="7">{
                tracker = &amp;FailureTracker{
                        ComponentID: componentID,
                        WindowStart: time.Now(),
                }
                fm.failureCounts[componentID] = tracker
        }</span>

        <span class="cov7" title="16">tracker.mu.Lock()
        tracker.Failures++
        tracker.TotalRequests++
        tracker.LastFailure = time.Now()
        tracker.mu.Unlock()

        // Update recovery tracker
        recoveryTracker, exists := fm.recoveryState[componentID]
        if !exists </span><span class="cov5" title="7">{
                recoveryTracker = &amp;RecoveryTracker{
                        ComponentID: componentID,
                }
                fm.recoveryState[componentID] = recoveryTracker
        }</span>

        <span class="cov7" title="16">recoveryTracker.mu.Lock()
        recoveryTracker.ConsecutiveSuccesses = 0
        recoveryTracker.InRecovery = true
        recoveryTracker.mu.Unlock()

        // Check if we should enter degraded mode
        failureRate := fm.getFailureRate(componentID)
        if fm.config.EnableGracefulDegradation &amp;&amp; failureRate &gt;= fm.config.DegradationThreshold &amp;&amp; !fm.degradedMode </span><span class="cov4" title="6">{
                fm.enterDegradedMode(componentID, failureRate)
        }</span>

        // Check if we should alert
        <span class="cov7" title="16">if failureRate &gt;= fm.config.AlertThreshold </span><span class="cov7" title="16">{
                fm.emitAlert(componentID, failureRate, err)
        }</span>
}

// getFailureRate calculates the failure rate for a component
func (fm *FallbackManager) getFailureRate(componentID string) float64 <span class="cov7" title="17">{
        tracker, exists := fm.failureCounts[componentID]
        if !exists || tracker.TotalRequests == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov7" title="17">tracker.mu.Lock()
        defer tracker.mu.Unlock()

        // Reset window if it's too old
        if time.Since(tracker.WindowStart) &gt; fm.config.FailureTrackingWindow </span><span class="cov6" title="12">{
                tracker.Failures = 1
                tracker.TotalRequests = 1
                tracker.WindowStart = time.Now()
                return 1.0
        }</span>

        <span class="cov4" title="5">return float64(tracker.Failures) / float64(tracker.TotalRequests)</span>
}

// enterDegradedMode enters graceful degradation mode
func (fm *FallbackManager) enterDegradedMode(componentID string, failureRate float64) <span class="cov4" title="6">{
        fm.degradedMode = true

        fm.emitEvent(events.Event{
                Type:      "distributed_degraded_mode_entered",
                SessionID: "system",
                Message:   fmt.Sprintf("Entered degraded mode due to high failure rate on %s", componentID),
                Data: map[string]interface{}{
                        "component_id": componentID,
                        "failure_rate": failureRate,
                        "threshold":    fm.config.DegradationThreshold,
                },
        })

        fm.logger.Log("warning", "Entered degraded mode", map[string]interface{}{
                "component_id": componentID,
                "failure_rate": failureRate,
        })
}</span>

// exitDegradedMode exits graceful degradation mode
func (fm *FallbackManager) exitDegradedMode() <span class="cov1" title="1">{
        fm.degradedMode = false

        fm.emitEvent(events.Event{
                Type:      "distributed_degraded_mode_exited",
                SessionID: "system",
                Message:   "Exited degraded mode - system recovered",
        })

        fm.logger.Log("info", "Exited degraded mode", nil)
}</span>

// emitAlert emits an alert for high failure rates
func (fm *FallbackManager) emitAlert(componentID string, failureRate float64, err error) <span class="cov7" title="16">{
        fm.emitEvent(events.Event{
                Type:      "distributed_failure_alert",
                SessionID: "system",
                Message:   fmt.Sprintf("High failure rate alert for %s", componentID),
                Data: map[string]interface{}{
                        "component_id": componentID,
                        "failure_rate": failureRate,
                        "threshold":    fm.config.AlertThreshold,
                        "error":        err.Error(),
                },
        })
}</span>

// monitorFailures monitors failure rates and manages degraded mode
func (fm *FallbackManager) monitorFailures() <span class="cov9" title="52">{
        ticker := time.NewTicker(fm.config.RecoveryCheckInterval)
        defer ticker.Stop()

        for </span><span class="cov9" title="52">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        fm.mu.Lock()

                        // Check if we should exit degraded mode
                        if fm.degradedMode </span><span class="cov0" title="0">{
                                shouldExit := true
                                for componentID := range fm.failureCounts </span><span class="cov0" title="0">{
                                        if fm.getFailureRate(componentID) &gt;= fm.config.DegradationThreshold </span><span class="cov0" title="0">{
                                                shouldExit = false
                                                break</span>
                                        }
                                }

                                <span class="cov0" title="0">if shouldExit </span><span class="cov0" title="0">{
                                        fm.exitDegradedMode()
                                }</span>
                        }

                        <span class="cov0" title="0">fm.mu.Unlock()</span>
                }
        }
}

// monitorRecovery monitors recovery progress
func (fm *FallbackManager) monitorRecovery() <span class="cov9" title="52">{
        ticker := time.NewTicker(fm.config.RecoveryCheckInterval)
        defer ticker.Stop()

        for </span><span class="cov9" title="52">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        fm.mu.Lock()

                        now := time.Now()
                        for componentID, tracker := range fm.recoveryState </span><span class="cov0" title="0">{
                                tracker.mu.Lock()

                                // Reset recovery state if no recent successes
                                if tracker.InRecovery &amp;&amp; now.Sub(tracker.LastSuccess) &gt; fm.config.RecoveryWindow </span><span class="cov0" title="0">{
                                        tracker.ConsecutiveSuccesses = 0
                                        tracker.InRecovery = false

                                        fm.logger.Log("info", "Recovery timeout expired", map[string]interface{}{
                                                "component_id": componentID,
                                        })
                                }</span>

                                <span class="cov0" title="0">tracker.mu.Unlock()</span>
                        }

                        <span class="cov0" title="0">fm.mu.Unlock()</span>
                }
        }
}

// trackOperation tracks operation metrics
func (fm *FallbackManager) trackOperation(componentID string, startTime time.Time) <span class="cov7" title="20">{
        duration := time.Since(startTime)

        // Emit metrics event
        fm.emitEvent(events.Event{
                Type:      "distributed_operation_metrics",
                SessionID: "system",
                Message:   fmt.Sprintf("Operation completed for %s", componentID),
                Data: map[string]interface{}{
                        "component_id": componentID,
                        "duration_ms":  duration.Milliseconds(),
                },
        })
}</span>

// GetStatus returns the current fallback system status
func (fm *FallbackManager) GetStatus() map[string]interface{} <span class="cov4" title="4">{
        fm.mu.RLock()
        defer fm.mu.RUnlock()

        components := make(map[string]interface{})

        for componentID, tracker := range fm.failureCounts </span><span class="cov4" title="5">{
                tracker.mu.Lock()
                var failureRate float64
                if tracker.TotalRequests &gt; 0 </span><span class="cov4" title="5">{
                        failureRate = float64(tracker.Failures) / float64(tracker.TotalRequests)
                }</span>
                <span class="cov4" title="5">tracker.mu.Unlock()

                recoveryTracker := fm.recoveryState[componentID]
                inRecovery := false
                if recoveryTracker != nil </span><span class="cov4" title="5">{
                        recoveryTracker.mu.Lock()
                        inRecovery = recoveryTracker.InRecovery
                        recoveryTracker.mu.Unlock()
                }</span>

                <span class="cov4" title="5">components[componentID] = map[string]interface{}{
                        "failure_rate":   failureRate,
                        "total_requests": tracker.TotalRequests,
                        "failures":       tracker.Failures,
                        "in_recovery":    inRecovery,
                }</span>
        }

        <span class="cov4" title="4">return map[string]interface{}{
                "degraded_mode": fm.degradedMode,
                "components":    components,
        }</span>
}

// emitEvent emits an event if event bus is available
func (fm *FallbackManager) emitEvent(event events.Event) <span class="cov9" title="59">{
        if fm.eventBus != nil </span><span class="cov9" title="59">{
                fm.eventBus.Publish(event)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package distributed

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "digital.vasic.translator/internal/config"
        "digital.vasic.translator/pkg/deployment"
        "digital.vasic.translator/pkg/events"
)

// defaultLogger provides a basic logger implementation
type defaultLogger struct{}

func (l *defaultLogger) Log(level, message string, fields map[string]interface{}) <span class="cov2" title="2">{
        log.Printf("[%s] %s %v", level, message, fields)
}</span>

// DistributedManager manages all distributed work functionality
type DistributedManager struct {
        config           *config.Config
        sshPool          *SSHPool
        pairingManager   *PairingManager
        distributedCoord *DistributedCoordinator
        fallbackManager  *FallbackManager
        versionManager   *VersionManager
        eventBus         *events.EventBus
        mu               sync.RWMutex
        initialized      bool
}

// NewDistributedManager creates a new distributed manager
func NewDistributedManager(cfg *config.Config, eventBus *events.EventBus, apiLogger *deployment.APICommunicationLogger) *DistributedManager <span class="cov9" title="51">{
        sshPool := NewSSHPool()
        pairingManager := NewPairingManager(sshPool, eventBus)

        // Create version manager
        versionManager := NewVersionManager(eventBus)

        // Create fallback manager with default config
        fallbackConfig := DefaultFallbackConfig()
        fallbackManager := NewFallbackManager(fallbackConfig, nil, eventBus, &amp;defaultLogger{})

        // Create distributed coordinator (will be initialized with local coordinator later)
        distributedCoord := NewDistributedCoordinator(nil, sshPool, pairingManager, fallbackManager, versionManager, eventBus, apiLogger)

        return &amp;DistributedManager{
                config:           cfg,
                sshPool:          sshPool,
                pairingManager:   pairingManager,
                distributedCoord: distributedCoord,
                fallbackManager:  fallbackManager,
                versionManager:   versionManager,
                eventBus:         eventBus,
                initialized:      false,
        }
}</span>

// Initialize initializes the distributed manager with worker configurations
func (dm *DistributedManager) Initialize(localCoordinator interface{}) error <span class="cov8" title="33">{
        dm.mu.Lock()
        defer dm.mu.Unlock()

        if dm.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf("distributed manager already initialized")
        }</span>

        // Set local coordinator reference
        <span class="cov8" title="33">dm.distributedCoord.localCoordinator = localCoordinator

        // Load worker configurations
        for workerID, workerCfg := range dm.config.Distributed.Workers </span><span class="cov0" title="0">{
                sshConfig := SSHConfig{
                        Host:       workerCfg.Host,
                        Port:       workerCfg.Port,
                        User:       workerCfg.User,
                        KeyFile:    workerCfg.KeyFile,
                        Password:   workerCfg.Password,
                        Timeout:    time.Duration(dm.config.Distributed.SSHTimeout) * time.Second,
                        MaxRetries: dm.config.Distributed.SSHMaxRetries,
                        RetryDelay: 5 * time.Second,
                }

                distWorkerCfg := &amp;WorkerConfig{
                        ID:          workerID,
                        Name:        workerCfg.Name,
                        SSH:         sshConfig,
                        Tags:        workerCfg.Tags,
                        MaxCapacity: workerCfg.MaxCapacity,
                        Enabled:     workerCfg.Enabled,
                }

                dm.sshPool.AddWorker(distWorkerCfg)
        }</span>

        <span class="cov8" title="33">dm.initialized = true

        dm.emitEvent(events.Event{
                Type:      "distributed_manager_initialized",
                SessionID: "system",
                Message:   fmt.Sprintf("Distributed manager initialized with %d workers", len(dm.config.Distributed.Workers)),
                Data: map[string]interface{}{
                        "worker_count": len(dm.config.Distributed.Workers),
                },
        })

        return nil</span>
}

// DiscoverAndPairWorkers discovers and pairs with all configured workers
func (dm *DistributedManager) DiscoverAndPairWorkers(ctx context.Context) error <span class="cov0" title="0">{
        dm.mu.RLock()
        if !dm.initialized </span><span class="cov0" title="0">{
                dm.mu.RUnlock()
                return fmt.Errorf("distributed manager not initialized")
        }</span>
        <span class="cov0" title="0">dm.mu.RUnlock()

        workers := dm.sshPool.GetWorkers()
        successCount := 0

        for workerID := range workers </span><span class="cov0" title="0">{
                if err := dm.discoverAndPairWorker(ctx, workerID); err != nil </span><span class="cov0" title="0">{
                        dm.emitWarning(fmt.Sprintf("Failed to discover/pair worker %s: %v", workerID, err))
                        continue</span>
                }
                <span class="cov0" title="0">successCount++</span>
        }

        // Discover remote instances
        <span class="cov0" title="0">if err := dm.distributedCoord.DiscoverRemoteInstances(ctx); err != nil </span><span class="cov0" title="0">{
                dm.emitWarning(fmt.Sprintf("Failed to discover remote instances: %v", err))
        }</span>

        <span class="cov0" title="0">dm.emitEvent(events.Event{
                Type:      "distributed_workers_paired",
                SessionID: "system",
                Message:   fmt.Sprintf("Successfully paired with %d/%d workers", successCount, len(workers)),
                Data: map[string]interface{}{
                        "paired_count":     successCount,
                        "total_count":      len(workers),
                        "remote_instances": dm.distributedCoord.GetRemoteInstanceCount(),
                },
        })

        return nil</span>
}

// discoverAndPairWorker discovers and pairs with a single worker
func (dm *DistributedManager) discoverAndPairWorker(ctx context.Context, workerID string) error <span class="cov0" title="0">{
        // Discover service
        service, err := dm.pairingManager.DiscoverService(ctx, workerID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to discover service: %w", err)
        }</span>

        // Check worker version and update if necessary
        <span class="cov0" title="0">if err := dm.ensureWorkerVersion(ctx, service); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure worker version: %w", err)
        }</span>

        // Pair with service
        <span class="cov0" title="0">if err := dm.pairingManager.PairWithService(workerID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pair with service: %w", err)
        }</span>

        <span class="cov0" title="0">dm.emitEvent(events.Event{
                Type:      "distributed_worker_discovered",
                SessionID: "system",
                Message:   fmt.Sprintf("Discovered and paired with worker %s (%s) v%s", workerID, service.Name, service.Version.CodebaseVersion),
                Data: map[string]interface{}{
                        "worker_id":    workerID,
                        "worker_name":  service.Name,
                        "host":         service.Host,
                        "capabilities": service.Capabilities,
                        "version":      service.Version.CodebaseVersion,
                },
        })

        return nil</span>
}

// ensureWorkerVersion ensures a worker is running the correct version
func (dm *DistributedManager) ensureWorkerVersion(ctx context.Context, service *RemoteService) error <span class="cov7" title="19">{
        // Check if worker version is up to date
        upToDate, err := dm.versionManager.CheckWorkerVersion(ctx, service)
        if err != nil </span><span class="cov7" title="18">{
                return fmt.Errorf("version check failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !upToDate </span><span class="cov0" title="0">{
                dm.emitWarning(fmt.Sprintf("Worker %s is outdated (current: %s, required: %s). Updating...",
                        service.WorkerID, service.Version.CodebaseVersion, dm.versionManager.GetLocalVersion().CodebaseVersion))

                // Update the worker
                if err := dm.versionManager.UpdateWorker(ctx, service); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("worker update failed: %w", err)
                }</span>

                <span class="cov0" title="0">dm.emitEvent(events.Event{
                        Type:      "distributed_worker_updated",
                        SessionID: "system",
                        Message:   fmt.Sprintf("Successfully updated worker %s to version %s", service.WorkerID, dm.versionManager.GetLocalVersion().CodebaseVersion),
                        Data: map[string]interface{}{
                                "worker_id": service.WorkerID,
                                "version":   dm.versionManager.GetLocalVersion().CodebaseVersion,
                        },
                })</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// TranslateDistributed performs distributed translation
func (dm *DistributedManager) TranslateDistributed(
        ctx context.Context,
        text string,
        contextHint string,
) (string, error) <span class="cov0" title="0">{

        dm.mu.RLock()
        if !dm.initialized </span><span class="cov0" title="0">{
                dm.mu.RUnlock()
                return "", fmt.Errorf("distributed manager not initialized")
        }</span>
        <span class="cov0" title="0">dm.mu.RUnlock()

        return dm.distributedCoord.TranslateWithDistributedRetry(ctx, text, contextHint)</span>
}

// GetStatus returns the status of all workers and instances
func (dm *DistributedManager) GetStatus() map[string]interface{} <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        workers := dm.sshPool.GetWorkers()
        pairedServices := dm.pairingManager.GetPairedServices()

        workerStatuses := make(map[string]interface{})
        for workerID, worker := range workers </span><span class="cov0" title="0">{
                status := "configured"
                if service, paired := pairedServices[workerID]; paired </span><span class="cov0" title="0">{
                        status = service.Status
                }</span>

                <span class="cov0" title="0">workerStatuses[workerID] = map[string]interface{}{
                        "name":     worker.Name,
                        "enabled":  worker.Enabled,
                        "status":   status,
                        "capacity": worker.MaxCapacity,
                }</span>
        }

        <span class="cov2" title="2">return map[string]interface{}{
                "initialized":        dm.initialized,
                "enabled":            dm.config.Distributed.Enabled,
                "workers":            workerStatuses,
                "active_connections": dm.sshPool.GetActiveConnections(),
                "remote_instances":   dm.distributedCoord.GetRemoteInstanceCount(),
                "paired_workers":     len(pairedServices),
        }</span>
}

// AddWorker adds a new worker dynamically
func (dm *DistributedManager) AddWorker(workerID string, workerCfg *WorkerConfig) error <span class="cov2" title="2">{
        dm.mu.Lock()
        defer dm.mu.Unlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return fmt.Errorf("distributed manager not initialized")
        }</span>

        <span class="cov1" title="1">dm.sshPool.AddWorker(workerCfg)
        dm.config.Distributed.Workers[workerID] = config.WorkerConfig{
                Name:        workerCfg.Name,
                Host:        workerCfg.SSH.Host,
                Port:        workerCfg.SSH.Port,
                User:        workerCfg.SSH.User,
                KeyFile:     workerCfg.SSH.KeyFile,
                Password:    workerCfg.SSH.Password,
                MaxCapacity: workerCfg.MaxCapacity,
                Tags:        workerCfg.Tags,
                Enabled:     workerCfg.Enabled,
        }

        dm.emitEvent(events.Event{
                Type:      "distributed_worker_added",
                SessionID: "system",
                Message:   fmt.Sprintf("Worker %s added to distributed pool", workerID),
                Data: map[string]interface{}{
                        "worker_id":   workerID,
                        "worker_name": workerCfg.Name,
                },
        })

        return nil</span>
}

// RemoveWorker removes a worker
func (dm *DistributedManager) RemoveWorker(workerID string) error <span class="cov2" title="2">{
        dm.mu.Lock()
        defer dm.mu.Unlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return fmt.Errorf("distributed manager not initialized")
        }</span>

        <span class="cov1" title="1">dm.sshPool.RemoveWorker(workerID)
        delete(dm.config.Distributed.Workers, workerID)

        dm.emitEvent(events.Event{
                Type:      "distributed_worker_removed",
                SessionID: "system",
                Message:   fmt.Sprintf("Worker %s removed from distributed pool", workerID),
                Data: map[string]interface{}{
                        "worker_id": workerID,
                },
        })

        return nil</span>
}

// PairWorker pairs with a worker
func (dm *DistributedManager) PairWorker(workerID string) error <span class="cov2" title="2">{
        dm.mu.RLock()
        if !dm.initialized </span><span class="cov1" title="1">{
                dm.mu.RUnlock()
                return fmt.Errorf("distributed manager not initialized")
        }</span>
        <span class="cov1" title="1">dm.mu.RUnlock()

        return dm.pairingManager.PairWithService(workerID)</span>
}

// UnpairWorker unpairs from a worker
func (dm *DistributedManager) UnpairWorker(workerID string) error <span class="cov2" title="2">{
        dm.mu.RLock()
        if !dm.initialized </span><span class="cov1" title="1">{
                dm.mu.RUnlock()
                return fmt.Errorf("distributed manager not initialized")
        }</span>
        <span class="cov1" title="1">dm.mu.RUnlock()

        return dm.pairingManager.UnpairService(workerID)</span>
}

// emitEvent emits an event if event bus is available
func (dm *DistributedManager) emitEvent(event events.Event) <span class="cov10" title="67">{
        if dm.eventBus != nil </span><span class="cov8" title="37">{
                dm.eventBus.Publish(event)
        }</span>
}

// emitWarning emits a warning event
func (dm *DistributedManager) emitWarning(message string) <span class="cov2" title="2">{
        if dm.eventBus != nil </span><span class="cov1" title="1">{
                dm.eventBus.Publish(events.Event{
                        Type:      "distributed_warning",
                        SessionID: "system",
                        Message:   message,
                })
        }</span>
}

// Close shuts down the distributed manager
func (dm *DistributedManager) Close() error <span class="cov8" title="32">{
        dm.mu.Lock()
        defer dm.mu.Unlock()

        dm.pairingManager.Close()
        dm.sshPool.Close()

        dm.emitEvent(events.Event{
                Type:      "distributed_manager_shutdown",
                SessionID: "system",
                Message:   "Distributed manager shut down",
        })

        return nil
}</span>

// GetWorkerByID returns a worker service by ID
func (dm *DistributedManager) GetWorkerByID(workerID string) *RemoteService <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">pairedServices := dm.pairingManager.GetPairedServices()
        if service, exists := pairedServices[workerID]; exists </span><span class="cov0" title="0">{
                return service
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// RollbackWorker rolls back a worker to its previous state
func (dm *DistributedManager) RollbackWorker(ctx context.Context, service *RemoteService) error <span class="cov2" title="2">{
        dm.mu.RLock()
        if !dm.initialized </span><span class="cov1" title="1">{
                dm.mu.RUnlock()
                return fmt.Errorf("distributed manager not initialized")
        }</span>
        <span class="cov1" title="1">dm.mu.RUnlock()

        return dm.versionManager.rollbackWorkerUpdate(ctx, service)</span>
}

// GetVersionMetrics returns version management metrics
func (dm *DistributedManager) GetVersionMetrics() *VersionMetrics <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return &amp;VersionMetrics{}
        }</span>

        <span class="cov1" title="1">return dm.versionManager.GetMetrics()</span>
}

// GetVersionAlerts returns current version drift alerts
func (dm *DistributedManager) GetVersionAlerts() []*DriftAlert <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return []*DriftAlert{}
        }</span>

        <span class="cov1" title="1">return dm.versionManager.GetAlerts()</span>
}

// GetVersionHealth returns overall version management health status
func (dm *DistributedManager) GetVersionHealth() map[string]interface{} <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return map[string]interface{}{
                        "status":       "uninitialized",
                        "health_score": 0.0,
                }
        }</span>

        <span class="cov1" title="1">return dm.versionManager.GetHealthStatus()</span>
}

// GetPairedServices returns the paired services map
func (dm *DistributedManager) GetPairedServices() map[string]*RemoteService <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return make(map[string]*RemoteService)
        }</span>

        <span class="cov1" title="1">return dm.pairingManager.GetPairedServices()</span>
}

// CheckVersionDrift performs version drift detection across all workers
func (dm *DistributedManager) CheckVersionDrift(ctx context.Context) []*DriftAlert <span class="cov2" title="2">{
        dm.mu.RLock()
        if !dm.initialized </span><span class="cov1" title="1">{
                dm.mu.RUnlock()
                return []*DriftAlert{}
        }</span>

        <span class="cov1" title="1">pairedServices := dm.pairingManager.GetPairedServices()
        dm.mu.RUnlock()

        // Convert map to slice for the version manager
        services := make([]*RemoteService, 0, len(pairedServices))
        for _, service := range pairedServices </span><span class="cov0" title="0">{
                services = append(services, service)
        }</span>

        <span class="cov1" title="1">return dm.versionManager.CheckVersionDrift(ctx, services)</span>
}

// GetAlertHistory returns alert history
func (dm *DistributedManager) GetAlertHistory(limit int) []*DriftAlert <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return []*DriftAlert{}
        }</span>

        <span class="cov1" title="1">return dm.versionManager.GetAlertHistory(limit)</span>
}

// AcknowledgeAlert marks an alert as acknowledged
func (dm *DistributedManager) AcknowledgeAlert(alertID, acknowledgedBy string) bool <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov1" title="1">return dm.versionManager.AcknowledgeAlert(alertID, acknowledgedBy)</span>
}

// AddAlertChannel adds an alert notification channel
func (dm *DistributedManager) AddAlertChannel(channel AlertChannel) <span class="cov2" title="2">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if !dm.initialized </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="1">dm.versionManager.AddAlertChannel(channel)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package distributed

import (
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "digital.vasic.translator/pkg/events"
)

// RemoteService represents a remote translator service
type RemoteService struct {
        WorkerID     string              `json:"worker_id"`
        Name         string              `json:"name"`
        Host         string              `json:"host"`
        Port         int                 `json:"port"`
        Protocol     string              `json:"protocol"` // http, https, http3
        Status       string              `json:"status"`   // online, offline, paired, updating, outdated
        Capabilities ServiceCapabilities `json:"capabilities"`
        Version      VersionInfo         `json:"version"`
        LastSeen     time.Time           `json:"last_seen"`
        PairedAt     *time.Time          `json:"paired_at,omitempty"`
}

// ServiceCapabilities represents what the remote service can do
type ServiceCapabilities struct {
        Providers         []string `json:"providers"`
        MaxConcurrent     int      `json:"max_concurrent"`
        SupportsBatch     bool     `json:"supports_batch"`
        SupportsWebSocket bool     `json:"supports_websocket"`
        LocalLLMs         []string `json:"local_llms,omitempty"` // ollama, llamacpp models
}

// VersionInfo represents version information for codebase and components
type VersionInfo struct {
        CodebaseVersion string            `json:"codebase_version"`
        BuildTime       string            `json:"build_time"`
        GitCommit       string            `json:"git_commit"`
        GoVersion       string            `json:"go_version"`
        Components      map[string]string `json:"components"` // component -&gt; version
        LastUpdated     time.Time         `json:"last_updated"`
}

// PairingManager manages pairing with remote services
type PairingManager struct {
        services      map[string]*RemoteService
        sshPool       *SSHPool
        eventBus      *events.EventBus
        httpClient    *http.Client
        checkInterval time.Duration
        ctx           context.Context
        cancel        context.CancelFunc
}

// NewPairingManager creates a new pairing manager
func NewPairingManager(sshPool *SSHPool, eventBus *events.EventBus) *PairingManager <span class="cov10" title="65">{
        ctx, cancel := context.WithCancel(context.Background())

        // Create HTTP client with reasonable timeouts and TLS config for self-signed certs
        httpClient := &amp;http.Client{
                Timeout: 30 * time.Second,
                Transport: &amp;http.Transport{
                        MaxIdleConns:        10,
                        MaxIdleConnsPerHost: 2,
                        IdleConnTimeout:     90 * time.Second,
                        TLSClientConfig: &amp;tls.Config{
                                InsecureSkipVerify: true, // Accept self-signed certificates
                        },
                },
        }

        manager := &amp;PairingManager{
                services:      make(map[string]*RemoteService),
                sshPool:       sshPool,
                eventBus:      eventBus,
                httpClient:    httpClient,
                checkInterval: 30 * time.Second,
                ctx:           ctx,
                cancel:        cancel,
        }

        // Start health check routine
        go manager.healthCheckLoop()

        return manager
}</span>

// DiscoverService discovers a remote service via SSH
func (pm *PairingManager) DiscoverService(ctx context.Context, workerID string) (*RemoteService, error) <span class="cov1" title="1">{
        conn, err := pm.sshPool.GetConnection(workerID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get SSH connection: %w", err)
        }</span>

        // Check if translator service is running
        <span class="cov0" title="0">cmd := "ps aux | grep -E '(translator|translator-server)' | grep -v grep || echo 'not running'"
        output, err := conn.ExecuteCommand(ctx, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check service status: %w", err)
        }</span>

        <span class="cov0" title="0">if strings.Contains(string(output), "not running") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("translator service not running on worker %s", workerID)
        }</span>

        // Try to get service info via HTTP
        <span class="cov0" title="0">service, err := pm.queryServiceInfo(workerID)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback: create basic service info
                config := conn.Config
                service = &amp;RemoteService{
                        WorkerID: workerID,
                        Name:     config.Name,
                        Host:     config.SSH.Host,
                        Port:     8443, // Default port
                        Protocol: "https",
                        Status:   "online",
                        Capabilities: ServiceCapabilities{
                                Providers:     []string{"dictionary"}, // Basic assumption
                                MaxConcurrent: config.MaxCapacity,
                                SupportsBatch: true,
                        },
                        LastSeen: time.Now(),
                }
        }</span>

        <span class="cov0" title="0">pm.services[workerID] = service
        return service, nil</span>
}

// queryServiceInfo queries the remote service for its capabilities
func (pm *PairingManager) queryServiceInfo(workerID string) (*RemoteService, error) <span class="cov2" title="2">{
        conn, err := pm.sshPool.GetConnection(workerID)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov0" title="0">config := conn.Config

        // Try different ports and protocols
        endpoints := []struct {
                host  string
                port  int
                proto string
        }{
                {config.SSH.Host, 8443, "https"},
                {config.SSH.Host, 8080, "http"},
                {config.SSH.Host, 8443, "http"},
        }

        for _, endpoint := range endpoints </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/api/v1/providers", endpoint.proto, endpoint.host, endpoint.port)

                resp, err := pm.httpClient.Get(url)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Try to parse providers response
                <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var providers map[string]interface{}
                if err := json.Unmarshal(body, &amp;providers); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get health check info
                <span class="cov0" title="0">healthURL := fmt.Sprintf("%s://%s:%d/health", endpoint.proto, endpoint.host, endpoint.port)
                healthResp, err := pm.httpClient.Get(healthURL)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defer healthResp.Body.Close()

                var health map[string]interface{}
                if healthBody, err := io.ReadAll(healthResp.Body); err == nil </span><span class="cov0" title="0">{
                        json.Unmarshal(healthBody, &amp;health)
                }</span>

                // Create service info
                <span class="cov0" title="0">service := &amp;RemoteService{
                        WorkerID: workerID,
                        Name:     config.Name,
                        Host:     endpoint.host,
                        Port:     endpoint.port,
                        Protocol: endpoint.proto,
                        Status:   "online",
                        Capabilities: ServiceCapabilities{
                                MaxConcurrent: config.MaxCapacity,
                                SupportsBatch: true,
                        },
                        LastSeen: time.Now(),
                }

                // Extract providers from response
                if providersList, ok := providers["providers"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, p := range providersList </span><span class="cov0" title="0">{
                                if providerName, ok := p.(string); ok </span><span class="cov0" title="0">{
                                        service.Capabilities.Providers = append(service.Capabilities.Providers, providerName)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return service, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("could not reach service on worker %s", workerID)</span>
}

// PairWithService pairs with a discovered remote service
func (pm *PairingManager) PairWithService(workerID string) error <span class="cov2" title="2">{
        service, exists := pm.services[workerID]
        if !exists </span><span class="cov2" title="2">{
                return fmt.Errorf("service %s not discovered", workerID)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        service.Status = "paired"
        service.PairedAt = &amp;now

        // Emit pairing event
        pm.emitEvent(events.Event{
                Type:      "distributed_worker_paired",
                SessionID: "system",
                Message:   fmt.Sprintf("Successfully paired with remote worker %s", workerID),
                Data: map[string]interface{}{
                        "worker_id":    workerID,
                        "worker_name":  service.Name,
                        "host":         service.Host,
                        "capabilities": service.Capabilities,
                },
        })

        return nil</span>
}

// UnpairService unpairs from a remote service
func (pm *PairingManager) UnpairService(workerID string) error <span class="cov2" title="2">{
        service, exists := pm.services[workerID]
        if !exists </span><span class="cov2" title="2">{
                return fmt.Errorf("service %s not found", workerID)
        }</span>

        <span class="cov0" title="0">service.Status = "online"
        service.PairedAt = nil

        // Emit unpairing event
        pm.emitEvent(events.Event{
                Type:      "distributed_worker_unpaired",
                SessionID: "system",
                Message:   fmt.Sprintf("Unpaired from remote worker %s", workerID),
                Data: map[string]interface{}{
                        "worker_id":   workerID,
                        "worker_name": service.Name,
                },
        })

        return nil</span>
}

// GetPairedServices returns all paired services
func (pm *PairingManager) GetPairedServices() map[string]*RemoteService <span class="cov5" title="9">{
        paired := make(map[string]*RemoteService)

        for id, service := range pm.services </span><span class="cov3" title="3">{
                if service.Status == "paired" </span><span class="cov2" title="2">{
                        paired[id] = service
                }</span>
        }

        <span class="cov5" title="7">return paired</span>
}

// GetServiceStatus returns the status of a service
func (pm *PairingManager) GetServiceStatus(workerID string) (string, error) <span class="cov2" title="2">{
        service, exists := pm.services[workerID]
        if !exists </span><span class="cov1" title="1">{
                return "unknown", fmt.Errorf("service %s not found", workerID)
        }</span>

        <span class="cov1" title="1">return service.Status, nil</span>
}

// healthCheckLoop periodically checks health of paired services
func (pm *PairingManager) healthCheckLoop() <span class="cov10" title="65">{
        ticker := time.NewTicker(pm.checkInterval)
        defer ticker.Stop()

        for </span><span class="cov10" title="65">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        pm.performHealthChecks()</span>

                case &lt;-pm.ctx.Done():<span class="cov9" title="41">
                        return</span>
                }
        }
}

// performHealthChecks checks health of all known services
func (pm *PairingManager) performHealthChecks() <span class="cov1" title="1">{
        for workerID, service := range pm.services </span><span class="cov0" title="0">{
                go pm.checkServiceHealth(workerID, service)
        }</span>
}

// checkServiceHealth checks the health of a single service
func (pm *PairingManager) checkServiceHealth(workerID string, service *RemoteService) <span class="cov1" title="1">{
        url := fmt.Sprintf("%s://%s:%d/health", service.Protocol, service.Host, service.Port)

        resp, err := pm.httpClient.Get(url)
        if err != nil </span><span class="cov1" title="1">{
                // Service is unreachable
                if service.Status != "offline" </span><span class="cov1" title="1">{
                        service.Status = "offline"
                        pm.emitEvent(events.Event{
                                Type:      "distributed_worker_offline",
                                SessionID: "system",
                                Message:   fmt.Sprintf("Remote worker %s went offline", workerID),
                                Data: map[string]interface{}{
                                        "worker_id": workerID,
                                        "error":     err.Error(),
                                },
                        })
                }</span>
                <span class="cov1" title="1">return</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        // Service is online
        wasOffline := service.Status == "offline"
        service.Status = "online"
        service.LastSeen = time.Now()

        if wasOffline </span><span class="cov0" title="0">{
                pm.emitEvent(events.Event{
                        Type:      "distributed_worker_online",
                        SessionID: "system",
                        Message:   fmt.Sprintf("Remote worker %s came back online", workerID),
                        Data: map[string]interface{}{
                                "worker_id": workerID,
                        },
                })
        }</span>
}

// emitEvent emits an event if event bus is available
func (pm *PairingManager) emitEvent(event events.Event) <span class="cov2" title="2">{
        if pm.eventBus != nil </span><span class="cov0" title="0">{
                pm.eventBus.Publish(event)
        }</span>
}

// Close stops the pairing manager
func (pm *PairingManager) Close() <span class="cov9" title="41">{
        pm.cancel()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package distributed

import (
        "crypto/sha256"
        "fmt"
        "sync"
        "time"

        "golang.org/x/crypto/ssh"
)

// PerformanceConfig holds performance-related configuration
type PerformanceConfig struct {
        // Connection Pooling
        MaxConnectionsPerWorker int
        ConnectionIdleTimeout   time.Duration
        ConnectionMaxLifetime   time.Duration

        // Request Batching
        EnableBatching bool
        BatchSize      int
        BatchTimeout   time.Duration

        // Caching
        EnableResultCaching  bool
        CacheTTL             time.Duration
        CacheCleanupInterval time.Duration
        MaxCacheSize         int

        // Load Balancing
        LoadBalancingStrategy string // "round_robin", "least_loaded", "weighted"
        HealthCheckInterval   time.Duration

        // Circuit Breaker
        EnableCircuitBreaker bool
        FailureThreshold     int
        RecoveryTimeout      time.Duration
        SuccessThreshold     int

        // Metrics
        EnableMetrics   bool
        MetricsInterval time.Duration
}

// DefaultPerformanceConfig returns optimized default configuration
func DefaultPerformanceConfig() *PerformanceConfig <span class="cov10" title="38">{
        return &amp;PerformanceConfig{
                MaxConnectionsPerWorker: 10,
                ConnectionIdleTimeout:   5 * time.Minute,
                ConnectionMaxLifetime:   30 * time.Minute,
                EnableBatching:          true,
                BatchSize:               10,
                BatchTimeout:            100 * time.Millisecond,
                EnableResultCaching:     true,
                CacheTTL:                10 * time.Minute,
                CacheCleanupInterval:    5 * time.Minute,
                MaxCacheSize:            10000,
                LoadBalancingStrategy:   "least_loaded",
                HealthCheckInterval:     30 * time.Second,
                EnableCircuitBreaker:    true,
                FailureThreshold:        5,
                RecoveryTimeout:         60 * time.Second,
                SuccessThreshold:        3,
                EnableMetrics:           true,
                MetricsInterval:         10 * time.Second,
        }
}</span>

// ConnectionPool manages a pool of connections with performance optimizations
type ConnectionPool struct {
        connections map[string]*ConnectionPoolEntry
        mu          sync.RWMutex
        config      *PerformanceConfig
        security    *SecurityConfig
        auditor     *SecurityAuditor
}

// ConnectionPoolEntry represents a pooled connection
type ConnectionPoolEntry struct {
        Connection *SSHConnection
        LastUsed   time.Time
        CreatedAt  time.Time
        InUse      bool
}

// NewConnectionPool creates a new connection pool
func NewConnectionPool(config *PerformanceConfig, security *SecurityConfig, auditor *SecurityAuditor) *ConnectionPool <span class="cov5" title="6">{
        pool := &amp;ConnectionPool{
                connections: make(map[string]*ConnectionPoolEntry),
                config:      config,
                security:    security,
                auditor:     auditor,
        }

        // Start cleanup goroutine
        go pool.cleanup()

        return pool
}</span>

// GetConnection gets a connection from the pool or creates a new one
func (cp *ConnectionPool) GetConnection(workerID string, worker *WorkerConfig) (*SSHConnection, error) <span class="cov3" title="3">{
        cp.mu.Lock()
        defer cp.mu.Unlock()

        key := cp.getConnectionKey(workerID)

        // Check if we have an available connection
        if entry, exists := cp.connections[key]; exists &amp;&amp; !entry.InUse </span><span class="cov2" title="2">{
                // Check if connection is still valid
                if time.Since(entry.CreatedAt) &lt; cp.config.ConnectionMaxLifetime &amp;&amp;
                        time.Since(entry.LastUsed) &lt; cp.config.ConnectionIdleTimeout </span><span class="cov1" title="1">{
                        entry.InUse = true
                        entry.LastUsed = time.Now()
                        return entry.Connection, nil
                }</span>
                // Connection is stale, remove it
                <span class="cov1" title="1">delete(cp.connections, key)</span>
        }

        // Create new connection
        <span class="cov2" title="2">conn, err := cp.createConnection(worker)
        if err != nil </span><span class="cov2" title="2">{
                cp.auditor.LogConnectionAttempt(workerID, fmt.Sprintf("%s:%d", worker.SSH.Host, worker.SSH.Port), false, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">entry := &amp;ConnectionPoolEntry{
                Connection: conn,
                LastUsed:   time.Now(),
                CreatedAt:  time.Now(),
                InUse:      true,
        }

        cp.connections[key] = entry
        cp.auditor.LogConnectionAttempt(workerID, fmt.Sprintf("%s:%d", worker.SSH.Host, worker.SSH.Port), true, "")

        return conn, nil</span>
}

// ReturnConnection returns a connection to the pool
func (cp *ConnectionPool) ReturnConnection(workerID string) <span class="cov1" title="1">{
        cp.mu.Lock()
        defer cp.mu.Unlock()

        key := cp.getConnectionKey(workerID)
        if entry, exists := cp.connections[key]; exists </span><span class="cov0" title="0">{
                entry.InUse = false
                entry.LastUsed = time.Now()
        }</span>
}

// RemoveConnection removes a connection from the pool
func (cp *ConnectionPool) RemoveConnection(workerID string) <span class="cov1" title="1">{
        cp.mu.Lock()
        defer cp.mu.Unlock()

        key := cp.getConnectionKey(workerID)
        delete(cp.connections, key)
}</span>

// createConnection creates a new SSH connection with security hardening
func (cp *ConnectionPool) createConnection(worker *WorkerConfig) (*SSHConnection, error) <span class="cov2" title="2">{
        // Validate network access
        address := fmt.Sprintf("%s:%d", worker.SSH.Host, worker.SSH.Port)
        if err := cp.security.ValidateNetworkAccess(address); err != nil </span><span class="cov0" title="0">{
                cp.auditor.LogNetworkAccess(address, false)
                return nil, fmt.Errorf("network access denied: %w", err)
        }</span>
        <span class="cov2" title="2">cp.auditor.LogNetworkAccess(address, true)

        // Create SSH config with security hardening
        authMethods := []ssh.AuthMethod{}

        if worker.SSH.KeyFile != "" </span><span class="cov0" title="0">{
                key, err := ssh.ParsePrivateKey([]byte(worker.SSH.KeyFile))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse private key: %w", err)
                }</span>
                <span class="cov0" title="0">authMethods = append(authMethods, ssh.PublicKeys(key))
                cp.auditor.LogAuthAttempt(worker.ID, worker.SSH.User, "public_key", true)</span>
        }

        <span class="cov2" title="2">if worker.SSH.Password != "" </span><span class="cov0" title="0">{
                authMethods = append(authMethods, ssh.Password(worker.SSH.Password))
                cp.auditor.LogAuthAttempt(worker.ID, worker.SSH.User, "password", true)
        }</span>

        <span class="cov2" title="2">sshConfig, err := cp.security.SecureSSHConfig(worker.SSH.User, authMethods)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create secure SSH config: %w", err)
        }</span>

        // Create connection with timeout
        <span class="cov2" title="2">conn, err := ssh.Dial("tcp", address, sshConfig)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("SSH dial failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SSHConnection{
                Config:    worker,
                Client:    conn,
                LastUsed:  time.Now(),
                CreatedAt: time.Now(),
        }, nil</span>
}

// getConnectionKey generates a unique key for connection pooling
func (cp *ConnectionPool) getConnectionKey(workerID string) string <span class="cov5" title="7">{
        return fmt.Sprintf("worker:%s", workerID)
}</span>

// cleanup periodically removes idle and expired connections
func (cp *ConnectionPool) cleanup() <span class="cov5" title="6">{
        ticker := time.NewTicker(cp.config.CacheCleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov5" title="6">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cp.mu.Lock()
                        now := time.Now()

                        for key, entry := range cp.connections </span><span class="cov0" title="0">{
                                // Remove connections that are:
                                // 1. Not in use and idle for too long
                                // 2. Exceeded maximum lifetime
                                if (!entry.InUse &amp;&amp; now.Sub(entry.LastUsed) &gt; cp.config.ConnectionIdleTimeout) ||
                                        now.Sub(entry.CreatedAt) &gt; cp.config.ConnectionMaxLifetime </span><span class="cov0" title="0">{
                                        entry.Connection.Close()
                                        delete(cp.connections, key)
                                }</span>
                        }
                        <span class="cov0" title="0">cp.mu.Unlock()</span>
                }
        }
}

// GetPoolStats returns connection pool statistics
func (cp *ConnectionPool) GetPoolStats() map[string]interface{} <span class="cov1" title="1">{
        cp.mu.RLock()
        defer cp.mu.RUnlock()

        total := len(cp.connections)
        inUse := 0
        idle := 0

        for _, entry := range cp.connections </span><span class="cov0" title="0">{
                if entry.InUse </span><span class="cov0" title="0">{
                        inUse++
                }</span> else<span class="cov0" title="0"> {
                        idle++
                }</span>
        }

        <span class="cov1" title="1">return map[string]interface{}{
                "total_connections":  total,
                "active_connections": inUse,
                "idle_connections":   idle,
                "max_per_worker":     cp.config.MaxConnectionsPerWorker,
        }</span>
}

// CacheEntry represents a cached item
type CacheEntry struct {
        Value     string
        ExpiresAt time.Time
}

// ResultCache provides caching for translation results
type ResultCache struct {
        cache   map[string]*CacheEntry
        maxSize int
        ttl     time.Duration
        mu      sync.RWMutex
}

// NewResultCache creates a new result cache
func NewResultCache(config *PerformanceConfig) *ResultCache <span class="cov5" title="6">{
        rc := &amp;ResultCache{
                cache:   make(map[string]*CacheEntry),
                maxSize: config.MaxCacheSize,
                ttl:     config.CacheTTL,
        }

        // Start cleanup goroutine
        go rc.cleanup(config.CacheCleanupInterval)

        return rc
}</span>

// Get retrieves a cached result
func (rc *ResultCache) Get(key string) (string, bool) <span class="cov2" title="2">{
        rc.mu.RLock()
        defer rc.mu.RUnlock()

        entry, found := rc.cache[key]
        if !found </span><span class="cov1" title="1">{
                return "", false
        }</span>

        // Check if expired
        <span class="cov1" title="1">if time.Now().After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov1" title="1">return entry.Value, true</span>
}

// Set stores a result in the cache
func (rc *ResultCache) Set(key, value string) <span class="cov5" title="6">{
        rc.mu.Lock()
        defer rc.mu.Unlock()

        // Check cache size limit
        if len(rc.cache) &gt;= rc.maxSize </span><span class="cov0" title="0">{
                // Remove expired entries first
                rc.removeExpired()

                // If still at limit, remove oldest entry
                if len(rc.cache) &gt;= rc.maxSize </span><span class="cov0" title="0">{
                        rc.removeOldest()
                }</span>
        }

        <span class="cov5" title="6">rc.cache[key] = &amp;CacheEntry{
                Value:     value,
                ExpiresAt: time.Now().Add(rc.ttl),
        }</span>
}

// removeExpired removes expired cache entries
func (rc *ResultCache) removeExpired() <span class="cov2" title="2">{
        now := time.Now()
        for key, entry := range rc.cache </span><span class="cov2" title="2">{
                if now.After(entry.ExpiresAt) </span><span class="cov1" title="1">{
                        delete(rc.cache, key)
                }</span>
        }
}

// removeOldest removes the oldest cache entry
func (rc *ResultCache) removeOldest() <span class="cov2" title="2">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range rc.cache </span><span class="cov3" title="3">{
                if oldestKey == "" || entry.ExpiresAt.Before(oldestTime) </span><span class="cov2" title="2">{
                        oldestKey = key
                        oldestTime = entry.ExpiresAt
                }</span>
        }

        <span class="cov2" title="2">if oldestKey != "" </span><span class="cov1" title="1">{
                delete(rc.cache, oldestKey)
        }</span>
}

// cleanup periodically removes expired entries
func (rc *ResultCache) cleanup(interval time.Duration) <span class="cov5" title="6">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov5" title="6">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rc.mu.Lock()
                        rc.removeExpired()
                        rc.mu.Unlock()</span>
                }
        }
}

// generateCacheKey generates a cache key for translation requests
func (rc *ResultCache) GenerateCacheKey(text, contextHint, provider, model string) string <span class="cov1" title="1">{
        hash := sha256.Sum256([]byte(fmt.Sprintf("%s|%s|%s|%s", text, contextHint, provider, model)))
        return fmt.Sprintf("%x", hash)
}</span>

// CircuitBreaker implements circuit breaker pattern for fault tolerance
type CircuitBreaker struct {
        failureThreshold int
        recoveryTimeout  time.Duration
        successThreshold int

        failures    int
        lastFailure time.Time
        successes   int
        state       CircuitState
        mu          sync.RWMutex
}

type CircuitState int

const (
        StateClosed CircuitState = iota
        StateOpen
        StateHalfOpen
)

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(failureThreshold int, recoveryTimeout time.Duration, successThreshold int) *CircuitBreaker <span class="cov2" title="2">{
        return &amp;CircuitBreaker{
                failureThreshold: failureThreshold,
                recoveryTimeout:  recoveryTimeout,
                successThreshold: successThreshold,
                state:            StateClosed,
        }
}</span>

// Call executes a function with circuit breaker protection
func (cb *CircuitBreaker) Call(fn func() error) error <span class="cov2" title="2">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        switch cb.state </span>{
        case StateOpen:<span class="cov0" title="0">
                if time.Since(cb.lastFailure) &lt; cb.recoveryTimeout </span><span class="cov0" title="0">{
                        return fmt.Errorf("circuit breaker is open")
                }</span>
                <span class="cov0" title="0">cb.state = StateHalfOpen
                cb.successes = 0
                fallthrough</span>

        case StateHalfOpen:<span class="cov0" title="0">
                err := fn()
                if err != nil </span><span class="cov0" title="0">{
                        cb.failures++
                        cb.lastFailure = time.Now()
                        cb.state = StateOpen
                        return err
                }</span>

                <span class="cov0" title="0">cb.successes++
                if cb.successes &gt;= cb.successThreshold </span><span class="cov0" title="0">{
                        cb.state = StateClosed
                        cb.failures = 0
                }</span>
                <span class="cov0" title="0">return nil</span>

        case StateClosed:<span class="cov2" title="2">
                err := fn()
                if err != nil </span><span class="cov1" title="1">{
                        cb.failures++
                        if cb.failures &gt;= cb.failureThreshold </span><span class="cov1" title="1">{
                                cb.state = StateOpen
                                cb.lastFailure = time.Now()
                        }</span>
                        <span class="cov1" title="1">return err</span>
                }
                <span class="cov1" title="1">cb.failures = 0
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("invalid circuit breaker state")</span>
}

// GetState returns the current circuit breaker state
func (cb *CircuitBreaker) GetState() CircuitState <span class="cov2" title="2">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()
        return cb.state
}</span>

// BatchProcessor handles request batching for improved performance
type BatchProcessor struct {
        batchSize int
        timeout   time.Duration
        processFn func([]interface{}) error
        batches   map[string]*Batch
        mu        sync.RWMutex
}

// Batch represents a batch of requests
type Batch struct {
        ID        string
        Requests  []interface{}
        CreatedAt time.Time
        Timer     *time.Timer
}

// NewBatchProcessor creates a new batch processor
func NewBatchProcessor(batchSize int, timeout time.Duration, processFn func([]interface{}) error) *BatchProcessor <span class="cov3" title="3">{
        return &amp;BatchProcessor{
                batchSize: batchSize,
                timeout:   timeout,
                processFn: processFn,
                batches:   make(map[string]*Batch),
        }
}</span>

// AddRequest adds a request to be batched
func (bp *BatchProcessor) AddRequest(batchID string, request interface{}) error <span class="cov2" title="2">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        batch, exists := bp.batches[batchID]
        if !exists </span><span class="cov2" title="2">{
                batch = &amp;Batch{
                        ID:        batchID,
                        Requests:  make([]interface{}, 0, bp.batchSize),
                        CreatedAt: time.Now(),
                }
                bp.batches[batchID] = batch
        }</span>

        <span class="cov2" title="2">batch.Requests = append(batch.Requests, request)

        // If batch is full, process it immediately
        if len(batch.Requests) &gt;= bp.batchSize </span><span class="cov0" title="0">{
                return bp.processBatch(batchID)
        }</span>

        // Set timeout if not already set
        <span class="cov2" title="2">if batch.Timer == nil </span><span class="cov2" title="2">{
                batch.Timer = time.AfterFunc(bp.timeout, func() </span><span class="cov1" title="1">{
                        bp.mu.Lock()
                        defer bp.mu.Unlock()
                        bp.processBatch(batchID)
                }</span>)
        }

        <span class="cov2" title="2">return nil</span>
}

// processBatch processes a batch of requests
func (bp *BatchProcessor) processBatch(batchID string) error <span class="cov2" title="2">{
        batch, exists := bp.batches[batchID]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Cancel timer if it exists
        <span class="cov2" title="2">if batch.Timer != nil </span><span class="cov2" title="2">{
                batch.Timer.Stop()
        }</span>

        // Process the batch
        <span class="cov2" title="2">err := bp.processFn(batch.Requests)

        // Remove the batch
        delete(bp.batches, batchID)

        return err</span>
}

// FlushAll flushes all pending batches
func (bp *BatchProcessor) FlushAll() error <span class="cov1" title="1">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        var lastErr error
        for batchID := range bp.batches </span><span class="cov1" title="1">{
                if err := bp.processBatch(batchID); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                }</span>
        }

        <span class="cov1" title="1">return lastErr</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package distributed

import (
        "testing"
        "time"
)

func TestDefaultPerformanceConfig(t *testing.T) <span class="cov0" title="0">{
        t.Run("DefaultConfiguration", func(t *testing.T) </span><span class="cov0" title="0">{
                config := DefaultPerformanceConfig()
                
                // Test connection pooling defaults
                if config.MaxConnectionsPerWorker != 10 </span><span class="cov0" title="0">{
                        t.Errorf("Expected max connections per worker to be 10, got %d", config.MaxConnectionsPerWorker)
                }</span>
                
                <span class="cov0" title="0">if config.ConnectionIdleTimeout != 5*time.Minute </span><span class="cov0" title="0">{
                        t.Errorf("Expected connection idle timeout to be 5m, got %v", config.ConnectionIdleTimeout)
                }</span>
                
                <span class="cov0" title="0">if config.ConnectionMaxLifetime != 30*time.Minute </span><span class="cov0" title="0">{
                        t.Errorf("Expected connection max lifetime to be 30m, got %v", config.ConnectionMaxLifetime)
                }</span>
                
                // Test batching defaults
                <span class="cov0" title="0">if !config.EnableBatching </span><span class="cov0" title="0">{
                        t.Error("Expected batching to be enabled")
                }</span>
                
                <span class="cov0" title="0">if config.BatchSize != 10 </span><span class="cov0" title="0">{
                        t.Errorf("Expected batch size to be 10, got %d", config.BatchSize)
                }</span>
                
                <span class="cov0" title="0">if config.BatchTimeout != 100*time.Millisecond </span><span class="cov0" title="0">{
                        t.Errorf("Expected batch timeout to be 100ms, got %v", config.BatchTimeout)
                }</span>
                
                // Test caching defaults
                <span class="cov0" title="0">if !config.EnableResultCaching </span><span class="cov0" title="0">{
                        t.Error("Expected result caching to be enabled")
                }</span>
                
                <span class="cov0" title="0">if config.CacheTTL != 10*time.Minute </span><span class="cov0" title="0">{
                        t.Errorf("Expected cache TTL to be 10m, got %v", config.CacheTTL)
                }</span>
                
                <span class="cov0" title="0">if config.MaxCacheSize != 10000 </span><span class="cov0" title="0">{
                        t.Errorf("Expected max cache size to be 10000, got %d", config.MaxCacheSize)
                }</span>
                
                // Test load balancing defaults
                <span class="cov0" title="0">if config.LoadBalancingStrategy != "least_loaded" </span><span class="cov0" title="0">{
                        t.Errorf("Expected load balancing strategy to be 'least_loaded', got '%s'", config.LoadBalancingStrategy)
                }</span>
                
                <span class="cov0" title="0">if config.HealthCheckInterval != 30*time.Second </span><span class="cov0" title="0">{
                        t.Errorf("Expected health check interval to be 30s, got %v", config.HealthCheckInterval)
                }</span>
                
                // Test circuit breaker defaults
                <span class="cov0" title="0">if !config.EnableCircuitBreaker </span><span class="cov0" title="0">{
                        t.Error("Expected circuit breaker to be enabled")
                }</span>
                
                <span class="cov0" title="0">if config.FailureThreshold != 5 </span><span class="cov0" title="0">{
                        t.Errorf("Expected failure threshold to be 5, got %d", config.FailureThreshold)
                }</span>
                
                <span class="cov0" title="0">if config.RecoveryTimeout != 60*time.Second </span><span class="cov0" title="0">{
                        t.Errorf("Expected recovery timeout to be 60s, got %v", config.RecoveryTimeout)
                }</span>
                
                <span class="cov0" title="0">if config.SuccessThreshold != 3 </span><span class="cov0" title="0">{
                        t.Errorf("Expected success threshold to be 3, got %d", config.SuccessThreshold)
                }</span>
                
                // Test metrics defaults
                <span class="cov0" title="0">if !config.EnableMetrics </span><span class="cov0" title="0">{
                        t.Error("Expected metrics to be enabled")
                }</span>
                
                <span class="cov0" title="0">if config.MetricsInterval != 10*time.Second </span><span class="cov0" title="0">{
                        t.Errorf("Expected metrics interval to be 10s, got %v", config.MetricsInterval)
                }</span>
        })
}

func TestNewConnectionPool(t *testing.T) <span class="cov0" title="0">{
        t.Run("Constructor", func(t *testing.T) </span><span class="cov0" title="0">{
                config := DefaultPerformanceConfig()
                security := DefaultSecurityConfig()
                auditor := NewSecurityAuditor(false, &amp;MockSecurityLogger{})
                
                pool := NewConnectionPool(config, security, auditor)
                
                if pool == nil </span><span class="cov0" title="0">{
                        t.Error("Expected non-nil connection pool")
                }</span>
                
                <span class="cov0" title="0">if pool.config != config </span><span class="cov0" title="0">{
                        t.Error("Expected config to be set correctly")
                }</span>
                
                <span class="cov0" title="0">if pool.security != security </span><span class="cov0" title="0">{
                        t.Error("Expected security to be set correctly")
                }</span>
                
                <span class="cov0" title="0">if pool.auditor != auditor </span><span class="cov0" title="0">{
                        t.Error("Expected auditor to be set correctly")
                }</span>
        })
}

func TestNewResultCache(t *testing.T) <span class="cov0" title="0">{
        t.Run("Constructor", func(t *testing.T) </span><span class="cov0" title="0">{
                config := DefaultPerformanceConfig()
                cache := NewResultCache(config)
                
                if cache == nil </span><span class="cov0" title="0">{
                        t.Error("Expected non-nil result cache")
                }</span>
                
                // Test that it's empty initially
                // No easy way to check cache size without adding size tracking
                // This will be tested through Get/Set operations
        })
}

func TestResultCache_BasicOperations(t *testing.T) <span class="cov0" title="0">{
        t.Run("GetAndSet", func(t *testing.T) </span><span class="cov0" title="0">{
                config := DefaultPerformanceConfig()
                cache := NewResultCache(config)
                
                key := "test-key"
                value := "test-value"
                
                // Test getting non-existent value
                result, found := cache.Get(key)
                if found </span><span class="cov0" title="0">{
                        t.Error("Expected not to find value")
                }</span>
                <span class="cov0" title="0">if result != "" </span><span class="cov0" title="0">{
                        t.Errorf("Expected empty result for non-existent key, got '%s'", result)
                }</span>
                
                // Test setting a value
                <span class="cov0" title="0">cache.Set(key, value)
                
                // Test getting existing value
                result, found = cache.Get(key)
                if !found </span><span class="cov0" title="0">{
                        t.Error("Expected to find value")
                }</span>
                
                <span class="cov0" title="0">if result != value </span><span class="cov0" title="0">{
                        t.Errorf("Expected value '%s', got '%s'", value, result)
                }</span>
        })
}

func TestNewCircuitBreaker(t *testing.T) <span class="cov0" title="0">{
        t.Run("Constructor", func(t *testing.T) </span><span class="cov0" title="0">{
                config := DefaultPerformanceConfig()
                cb := NewCircuitBreaker(config.FailureThreshold, config.RecoveryTimeout, config.SuccessThreshold)
                
                if cb == nil </span><span class="cov0" title="0">{
                        t.Error("Expected non-nil circuit breaker")
                }</span>
                
                // Test initial state
                <span class="cov0" title="0">state := cb.GetState()
                if state != StateClosed </span><span class="cov0" title="0">{
                        t.Errorf("Expected initial state to be StateClosed, got %v", state)
                }</span>
        })
}

func TestNewBatchProcessor(t *testing.T) <span class="cov0" title="0">{
        t.Run("Constructor", func(t *testing.T) </span><span class="cov0" title="0">{
                config := DefaultPerformanceConfig()
                processor := NewBatchProcessor(config.BatchSize, config.BatchTimeout, func(requests []interface{}) error </span><span class="cov0" title="0">{
                        // Mock processing function
                        return nil
                }</span>)
                
                <span class="cov0" title="0">if processor == nil </span><span class="cov0" title="0">{
                        t.Error("Expected non-nil batch processor")
                }</span>
        })
}

func TestGenerateCacheKey(t *testing.T) <span class="cov0" title="0">{
        t.Run("CacheKeyGeneration", func(t *testing.T) </span><span class="cov0" title="0">{
                config := DefaultPerformanceConfig()
                cache := NewResultCache(config)
                
                key := cache.GenerateCacheKey("test-text", "", "test-provider", "test-model")
                
                if key == "" </span><span class="cov0" title="0">{
                        t.Error("Expected non-empty cache key")
                }</span>
                
                // Test that the same inputs generate the same key
                <span class="cov0" title="0">key2 := cache.GenerateCacheKey("test-text", "", "test-provider", "test-model")
                if key != key2 </span><span class="cov0" title="0">{
                        t.Error("Expected same inputs to generate same cache key")
                }</span>
                
                // Test that different inputs generate different keys
                <span class="cov0" title="0">key3 := cache.GenerateCacheKey("different-text", "", "test-provider", "test-model")
                if key == key3 </span><span class="cov0" title="0">{
                        t.Error("Expected different inputs to generate different cache keys")
                }</span>
        })
}</pre>
		
		<pre class="file" id="file6" style="display: none">package distributed

import (
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "log"
        "net"
        "os"
        "strings"
        "time"

        "golang.org/x/crypto/ssh"
)

// SecurityConfig holds security-related configuration
type SecurityConfig struct {
        // SSH Security
        SSHHostKeyVerification bool
        KnownHostsFile         string
        SSHCiphers             []string
        SSHKexAlgorithms       []string
        SSHMACs                []string

        // TLS Security
        TLSCertVerification bool
        TLSCAFile           string
        TLSMinVersion       uint16
        TLSMaxVersion       uint16
        TLSCipherSuites     []uint16

        // Authentication
        RequireMutualTLS bool
        ClientCertFile   string
        ClientKeyFile    string

        // Network Security
        AllowedNetworks         []string
        MaxConnectionsPerWorker int
        ConnectionTimeout       time.Duration
        RequestTimeout          time.Duration

        // Monitoring
        EnableSecurityAuditing bool
        SecurityLogFile        string
}

// DefaultSecurityConfig returns secure default configuration
func DefaultSecurityConfig() *SecurityConfig <span class="cov4" title="12">{
        return &amp;SecurityConfig{
                SSHHostKeyVerification: true,
                KnownHostsFile:         "~/.ssh/known_hosts",
                SSHCiphers: []string{
                        "aes128-gcm@openssh.com",
                        "aes256-gcm@openssh.com",
                        "chacha20-poly1305@openssh.com",
                },
                SSHKexAlgorithms: []string{
                        "curve25519-sha256",
                        "curve25519-sha256@libssh.org",
                        "ecdh-sha2-nistp256",
                        "ecdh-sha2-nistp384",
                        "ecdh-sha2-nistp521",
                },
                SSHMACs: []string{
                        "hmac-sha2-256-etm@openssh.com",
                        "hmac-sha2-512-etm@openssh.com",
                },
                TLSCertVerification: true,
                TLSMinVersion:       tls.VersionTLS12,
                TLSMaxVersion:       tls.VersionTLS13,
                TLSCipherSuites: []uint16{
                        tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                        tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
                        tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
                },
                MaxConnectionsPerWorker: 5,
                ConnectionTimeout:       30 * time.Second,
                RequestTimeout:          60 * time.Second,
                EnableSecurityAuditing:  true,
        }
}</span>

// SecureSSHConfig creates a hardened SSH client configuration
func (sc *SecurityConfig) SecureSSHConfig(user string, authMethods []ssh.AuthMethod) (*ssh.ClientConfig, error) <span class="cov1" title="2">{
        config := &amp;ssh.ClientConfig{
                User:    user,
                Auth:    authMethods,
                Timeout: sc.ConnectionTimeout,
                Config: ssh.Config{
                        Ciphers:      sc.SSHCiphers,
                        KeyExchanges: sc.SSHKexAlgorithms,
                        MACs:         sc.SSHMACs,
                },
        }

        // Set host key callback based on verification setting
        if sc.SSHHostKeyVerification </span><span class="cov1" title="2">{
                hostKeyCallback, err := sc.createHostKeyCallback()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create host key callback: %w", err)
                }</span>
                <span class="cov1" title="2">config.HostKeyCallback = hostKeyCallback</span>
        } else<span class="cov0" title="0"> {
                // Only allow insecure callback in development/testing
                config.HostKeyCallback = ssh.InsecureIgnoreHostKey()
        }</span>

        <span class="cov1" title="2">return config, nil</span>
}

// createHostKeyCallback creates a secure host key callback
func (sc *SecurityConfig) createHostKeyCallback() (ssh.HostKeyCallback, error) <span class="cov2" title="3">{
        if sc.KnownHostsFile == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("known hosts file not configured")
        }</span>

        // Expand home directory
        <span class="cov2" title="3">knownHostsFile := sc.KnownHostsFile
        if strings.HasPrefix(knownHostsFile, "~/") </span><span class="cov1" title="2">{
                homeDir := os.Getenv("HOME")
                if homeDir == "" </span><span class="cov0" title="0">{
                        homeDir = os.Getenv("USERPROFILE") // Windows fallback
                }</span>
                <span class="cov1" title="2">if homeDir == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("HOME/USERPROFILE environment variable not set")
                }</span>
                <span class="cov1" title="2">knownHostsFile = strings.Replace(knownHostsFile, "~/", homeDir+"/", 1)</span>
        }

        // Load and parse known hosts file
        <span class="cov2" title="3">hostKeyCallback, err := sc.loadKnownHosts(knownHostsFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load known hosts: %w", err)
        }</span>

        <span class="cov2" title="3">return hostKeyCallback, nil</span>
}

// loadKnownHosts loads and parses the known hosts file
func (sc *SecurityConfig) loadKnownHosts(filename string) (ssh.HostKeyCallback, error) <span class="cov3" title="5">{
        // Check if file exists
        if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov1" title="1">{
                // File doesn't exist, create an empty callback that will reject all connections
                return func(hostname string, remote net.Addr, key ssh.PublicKey) error </span><span class="cov1" title="1">{
                        return fmt.Errorf("known hosts file %s does not exist, cannot verify host key for %s", filename, hostname)
                }</span>, nil
        }

        // Read the known hosts file
        <span class="cov2" title="4">content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read known hosts file: %w", err)
        }</span>

        // Parse the known hosts file
        <span class="cov2" title="4">knownHosts := make(map[string]map[string]ssh.PublicKey)

        lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov6" title="69">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov3" title="6">{
                        continue</span>
                }

                // Parse host key line: "hostname keytype keydata [comment]"
                <span class="cov6" title="63">parts := strings.Fields(line)
                if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span> // Invalid line
                }

                <span class="cov6" title="63">hostnames := strings.Split(parts[0], ",")
                keyType := parts[1]
                keyData := parts[2]

                // Parse the public key
                publicKey, _, _, _, err := ssh.ParseAuthorizedKey([]byte(keyType + " " + keyData))
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to parse SSH key for host %s: %v", parts[0], err)
                        continue</span> // Invalid key
                }

                // Store for each hostname pattern
                <span class="cov6" title="63">for _, hostname := range hostnames </span><span class="cov6" title="63">{
                        if knownHosts[hostname] == nil </span><span class="cov5" title="33">{
                                knownHosts[hostname] = make(map[string]ssh.PublicKey)
                        }</span>
                        <span class="cov6" title="63">knownHosts[hostname][keyType] = publicKey</span>
                }
        }

        // Return callback function
        <span class="cov2" title="4">return func(hostname string, remote net.Addr, key ssh.PublicKey) error </span><span class="cov3" title="5">{
                // Check for exact hostname match
                if hostKeys, exists := knownHosts[hostname]; exists </span><span class="cov1" title="2">{
                        if storedKey, keyExists := hostKeys[key.Type()]; keyExists </span><span class="cov1" title="2">{
                                if keysEqual(key, storedKey) </span><span class="cov1" title="1">{
                                        return nil // Key matches
                                }</span> else<span class="cov1" title="1"> {
                                        return fmt.Errorf("host key verification failed: key mismatch for %s", hostname)
                                }</span>
                        }
                }

                // Check for hashed hostnames (implemented)
                <span class="cov2" title="3">if strings.HasPrefix(hostname, "|1|") </span><span class="cov0" title="0">{
                        // Handle hashed hostname format: |1|salt|hash
                        parts := strings.Split(hostname, "|")
                        if len(parts) &gt;= 4 </span><span class="cov0" title="0">{
                                salt := parts[2]
                                // Verify hash against known hosts
                                for knownHost, hostKeys := range knownHosts </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(knownHost, "|1|") </span><span class="cov0" title="0">{
                                                knownParts := strings.Split(knownHost, "|")
                                                if len(knownParts) &gt;= 4 &amp;&amp; knownParts[2] == salt </span><span class="cov0" title="0">{
                                                        // Hashes match, verify key
                                                        if storedKey, keyExists := hostKeys[key.Type()]; keyExists </span><span class="cov0" title="0">{
                                                                if keysEqual(key, storedKey) </span><span class="cov0" title="0">{
                                                                        return nil // Key matches
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }

                // Check for IP address if hostname is not found
                <span class="cov2" title="3">if tcpAddr, ok := remote.(*net.TCPAddr); ok </span><span class="cov1" title="2">{
                        remoteIP := tcpAddr.IP.String()
                        if remoteIP != hostname </span><span class="cov1" title="2">{
                                if hostKeys, exists := knownHosts[remoteIP]; exists </span><span class="cov0" title="0">{
                                        if storedKey, keyExists := hostKeys[key.Type()]; keyExists </span><span class="cov0" title="0">{
                                                if keysEqual(key, storedKey) </span><span class="cov0" title="0">{
                                                        return nil // Key matches
                                                }</span>
                                        }
                                }
                        }
                }

                // Check for wildcard patterns
                <span class="cov2" title="3">for pattern, hostKeys := range knownHosts </span><span class="cov5" title="32">{
                        if strings.Contains(pattern, "*") || strings.Contains(pattern, "?") </span><span class="cov0" title="0">{
                                // Simple wildcard matching (could be improved)
                                if sc.matchesPattern(hostname, pattern) </span><span class="cov0" title="0">{
                                        if storedKey, keyExists := hostKeys[key.Type()]; keyExists </span><span class="cov0" title="0">{
                                                if keysEqual(key, storedKey) </span><span class="cov0" title="0">{
                                                        return nil // Key matches
                                                }</span>
                                        }
                                }
                        }
                }

                <span class="cov2" title="3">return fmt.Errorf("host key verification failed: no matching key found for %s", hostname)</span>
        }, nil
}

// matchesPattern performs simple wildcard matching for hostnames
func (sc *SecurityConfig) matchesPattern(hostname, pattern string) bool <span class="cov3" title="8">{
        // Simple implementation - could be enhanced with proper glob matching
        if pattern == "*" </span><span class="cov1" title="2">{
                return true
        }</span>

        // For now, just check if pattern contains hostname or vice versa
        <span class="cov3" title="6">return strings.Contains(pattern, hostname) || strings.Contains(hostname, pattern)</span>
}

// keysEqual compares two SSH public keys for equality
func keysEqual(a, b ssh.PublicKey) bool <span class="cov2" title="4">{
        if a.Type() != b.Type() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="4">aBytes := a.Marshal()
        bBytes := b.Marshal()

        if len(aBytes) != len(bBytes) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="4">for i := range aBytes </span><span class="cov10" title="606">{
                if aBytes[i] != bBytes[i] </span><span class="cov1" title="2">{
                        return false
                }</span>
        }

        <span class="cov1" title="2">return true</span>
}

// SecureTLSConfig creates a hardened TLS configuration
func (sc *SecurityConfig) SecureTLSConfig() (*tls.Config, error) <span class="cov2" title="4">{
        tlsConfig := &amp;tls.Config{
                MinVersion:   sc.TLSMinVersion,
                MaxVersion:   sc.TLSMaxVersion,
                CipherSuites: sc.TLSCipherSuites,
        }

        // Certificate verification
        if sc.TLSCertVerification </span><span class="cov2" title="4">{
                tlsConfig.InsecureSkipVerify = false

                // Load CA certificate if specified
                if sc.TLSCAFile != "" </span><span class="cov1" title="1">{
                        caCert, err := os.ReadFile(sc.TLSCAFile)
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("failed to read CA file: %w", err)
                        }</span>

                        <span class="cov0" title="0">caCertPool := x509.NewCertPool()
                        if !caCertPool.AppendCertsFromPEM(caCert) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse CA certificate")
                        }</span>

                        <span class="cov0" title="0">tlsConfig.RootCAs = caCertPool</span>
                }
        } else<span class="cov0" title="0"> {
                tlsConfig.InsecureSkipVerify = true
        }</span>

        // Mutual TLS
        <span class="cov2" title="3">if sc.RequireMutualTLS </span><span class="cov1" title="1">{
                if sc.ClientCertFile == "" || sc.ClientKeyFile == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("client certificate and key required for mutual TLS")
                }</span>

                <span class="cov0" title="0">cert, err := tls.LoadX509KeyPair(sc.ClientCertFile, sc.ClientKeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load client certificate: %w", err)
                }</span>

                <span class="cov0" title="0">tlsConfig.Certificates = []tls.Certificate{cert}</span>
        }

        <span class="cov1" title="2">return tlsConfig, nil</span>
}

// ValidateNetworkAccess checks if the target address is in allowed networks
func (sc *SecurityConfig) ValidateNetworkAccess(address string) error <span class="cov1" title="2">{
        if len(sc.AllowedNetworks) == 0 </span><span class="cov1" title="2">{
                return nil // No restrictions
        }</span>

        <span class="cov0" title="0">host, _, err := net.SplitHostPort(address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid address format: %w", err)
        }</span>

        <span class="cov0" title="0">ip := net.ParseIP(host)
        if ip == nil </span><span class="cov0" title="0">{
                // Try to resolve hostname
                ips, err := net.LookupIP(host)
                if err != nil || len(ips) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve hostname: %w", err)
                }</span>
                <span class="cov0" title="0">ip = ips[0]</span>
        }

        <span class="cov0" title="0">for _, network := range sc.AllowedNetworks </span><span class="cov0" title="0">{
                _, ipNet, err := net.ParseCIDR(network)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid networks
                }

                <span class="cov0" title="0">if ipNet.Contains(ip) </span><span class="cov0" title="0">{
                        return nil // Allowed
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("address %s not in allowed networks", address)</span>
}

// SecurityAuditor logs security events
type SecurityAuditor struct {
        enabled bool
        logger  Logger
}

// Logger interface for security logging
type Logger interface {
        Log(level, message string, fields map[string]interface{})
}

// NewSecurityAuditor creates a new security auditor
func NewSecurityAuditor(enabled bool, logger Logger) *SecurityAuditor <span class="cov4" title="16">{
        return &amp;SecurityAuditor{
                enabled: enabled,
                logger:  logger,
        }
}</span>

// LogSecurityEvent logs a security-related event
func (sa *SecurityAuditor) LogSecurityEvent(eventType, message string, fields map[string]interface{}) <span class="cov4" title="16">{
        if !sa.enabled </span><span class="cov3" title="8">{
                return
        }</span>

        <span class="cov3" title="8">sa.logger.Log("security", message, map[string]interface{}{
                "event_type": eventType,
                "timestamp":  time.Now().UTC().Format(time.RFC3339),
                "details":    fields,
        })</span>
}

// LogConnectionAttempt logs SSH connection attempts
func (sa *SecurityAuditor) LogConnectionAttempt(workerID, address string, success bool, errorMsg string) <span class="cov3" title="5">{
        fields := map[string]interface{}{
                "worker_id": workerID,
                "address":   address,
                "success":   success,
        }

        if errorMsg != "" </span><span class="cov2" title="3">{
                fields["error"] = errorMsg
        }</span>

        <span class="cov3" title="5">sa.LogSecurityEvent("ssh_connection", "SSH connection attempt", fields)</span>
}

// LogAuthAttempt logs authentication attempts
func (sa *SecurityAuditor) LogAuthAttempt(workerID, user, method string, success bool) <span class="cov2" title="3">{
        sa.LogSecurityEvent("authentication", "Authentication attempt", map[string]interface{}{
                "worker_id": workerID,
                "user":      user,
                "method":    method,
                "success":   success,
        })
}</span>

// LogNetworkAccess logs network access attempts
func (sa *SecurityAuditor) LogNetworkAccess(address string, allowed bool) <span class="cov3" title="5">{
        sa.LogSecurityEvent("network_access", "Network access attempt", map[string]interface{}{
                "address": address,
                "allowed": allowed,
        })
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package distributed

import (
        "context"
        "fmt"
        "net"
        "os"
        "strings"
        "sync"
        "time"

        "golang.org/x/crypto/ssh"
)

// SSHConfig represents SSH connection configuration
type SSHConfig struct {
        Host           string        `json:"host"`
        Port           int           `json:"port"`
        User           string        `json:"user"`
        KeyFile        string        `json:"key_file,omitempty"`
        Password       string        `json:"password,omitempty"`
        KnownHostsFile string        `json:"known_hosts_file,omitempty"`
        Timeout        time.Duration `json:"timeout"`
        MaxRetries     int           `json:"max_retries"`
        RetryDelay     time.Duration `json:"retry_delay"`
}

// WorkerConfig represents a remote worker configuration
type WorkerConfig struct {
        ID          string    `json:"id"`
        Name        string    `json:"name"`
        SSH         SSHConfig `json:"ssh"`
        Tags        []string  `json:"tags,omitempty"`
        MaxCapacity int       `json:"max_capacity"`
        Enabled     bool      `json:"enabled"`
}

// SSHConnection represents an SSH connection to a remote worker
type SSHConnection struct {
        Config    *WorkerConfig
        Client    *ssh.Client
        LastUsed  time.Time
        CreatedAt time.Time
        mu        sync.RWMutex
}

// SSHPool manages a pool of SSH connections to remote workers
type SSHPool struct {
        connections map[string]*SSHConnection
        configs     map[string]*WorkerConfig
        mu          sync.RWMutex
        maxIdleTime time.Duration
        cleanupTick time.Duration
        ctx         context.Context
        cancel      context.CancelFunc
}

// NewSSHConfig creates default SSH configuration
func NewSSHConfig(host, user string) *SSHConfig <span class="cov6" title="14">{
        return &amp;SSHConfig{
                Host:       host,
                Port:       22,
                User:       user,
                Timeout:    30 * time.Second,
                MaxRetries: 3,
                RetryDelay: 5 * time.Second,
        }
}</span>

// NewWorkerConfig creates a new worker configuration
func NewWorkerConfig(id, name, host, user string) *WorkerConfig <span class="cov6" title="13">{
        return &amp;WorkerConfig{
                ID:          id,
                Name:        name,
                SSH:         *NewSSHConfig(host, user),
                MaxCapacity: 5, // Default capacity
                Enabled:     true,
        }
}</span>

// NewSSHPool creates a new SSH connection pool
func NewSSHPool() *SSHPool <span class="cov10" title="70">{
        ctx, cancel := context.WithCancel(context.Background())
        pool := &amp;SSHPool{
                connections: make(map[string]*SSHConnection),
                configs:     make(map[string]*WorkerConfig),
                maxIdleTime: 30 * time.Minute,
                cleanupTick: 5 * time.Minute,
                ctx:         ctx,
                cancel:      cancel,
        }

        // Start cleanup goroutine
        go pool.cleanup()

        return pool
}</span>

// AddWorker adds a worker configuration to the pool
func (p *SSHPool) AddWorker(config *WorkerConfig) <span class="cov4" title="5">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.configs[config.ID] = config
}</span>

// RemoveWorker removes a worker from the pool
func (p *SSHPool) RemoveWorker(workerID string) <span class="cov2" title="2">{
        p.mu.Lock()
        defer p.mu.Unlock()

        delete(p.configs, workerID)
        if conn, exists := p.connections[workerID]; exists </span><span class="cov0" title="0">{
                conn.Client.Close()
                delete(p.connections, workerID)
        }</span>
}

// GetConnection gets or creates an SSH connection for a worker
func (p *SSHPool) GetConnection(workerID string) (*SSHConnection, error) <span class="cov5" title="7">{
        p.mu.RLock()
        config, exists := p.configs[workerID]
        p.mu.RUnlock()

        if !exists </span><span class="cov4" title="5">{
                return nil, fmt.Errorf("worker %s not configured", workerID)
        }</span>

        <span class="cov2" title="2">if !config.Enabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("worker %s is disabled", workerID)
        }</span>

        <span class="cov1" title="1">p.mu.Lock()
        defer p.mu.Unlock()

        // Check if we have an existing connection
        if conn, exists := p.connections[workerID]; exists </span><span class="cov0" title="0">{
                conn.LastUsed = time.Now()
                return conn, nil
        }</span>

        // Create new connection
        <span class="cov1" title="1">conn, err := p.createConnection(config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create SSH connection to %s: %w", workerID, err)
        }</span>

        <span class="cov0" title="0">p.connections[workerID] = conn
        return conn, nil</span>
}

// createConnection creates a new SSH connection
func (p *SSHPool) createConnection(config *WorkerConfig) (*SSHConnection, error) <span class="cov1" title="1">{
        var authMethods []ssh.AuthMethod

        // Add key-based authentication if key file is provided
        if config.SSH.KeyFile != "" </span><span class="cov0" title="0">{
                key, err := ssh.ParsePrivateKey([]byte(config.SSH.KeyFile))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse private key: %w", err)
                }</span>
                <span class="cov0" title="0">authMethods = append(authMethods, ssh.PublicKeys(key))</span>
        }

        // Add password authentication if password is provided
        <span class="cov1" title="1">if config.SSH.Password != "" </span><span class="cov0" title="0">{
                authMethods = append(authMethods, ssh.Password(config.SSH.Password))
        }</span>

        <span class="cov1" title="1">if len(authMethods) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no authentication method configured")
        }</span>

        // Implement proper host key verification
        <span class="cov0" title="0">var hostKeyCallback ssh.HostKeyCallback

        if config.SSH.KnownHostsFile != "" </span><span class="cov0" title="0">{
                // Create a simple host key callback that checks known_hosts file
                hostKeyCallback = func(hostname string, remote net.Addr, key ssh.PublicKey) error </span><span class="cov0" title="0">{
                        knownHosts, err := os.ReadFile(config.SSH.KnownHostsFile)
                        if err != nil </span><span class="cov0" title="0">{
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        // If known_hosts file doesn't exist, create it with this key
                                        return appendToKnownHosts(config.SSH.KnownHostsFile, hostname, key)
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("failed to read known_hosts file: %w", err)</span>
                        }

                        // Check if key exists in known_hosts
                        <span class="cov0" title="0">keyLine := fmt.Sprintf("%s %s", hostname, strings.TrimSpace(string(key.Marshal())))
                        if strings.Contains(string(knownHosts), keyLine) </span><span class="cov0" title="0">{
                                return nil // Key found and matches
                        }</span>

                        // Key not found, append to known_hosts
                        <span class="cov0" title="0">return appendToKnownHosts(config.SSH.KnownHostsFile, hostname, key)</span>
                }
        } else<span class="cov0" title="0"> {
                // Fallback to insecure callback if no known_hosts file specified
                hostKeyCallback = ssh.InsecureIgnoreHostKey()
        }</span>

        <span class="cov0" title="0">sshConfig := &amp;ssh.ClientConfig{
                User:            config.SSH.User,
                Auth:            authMethods,
                HostKeyCallback: hostKeyCallback,
                Timeout:         config.SSH.Timeout,
        }

        addr := fmt.Sprintf("%s:%d", config.SSH.Host, config.SSH.Port)

        var client *ssh.Client
        var lastErr error

        // Retry connection
        for attempt := 0; attempt &lt;= config.SSH.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                var err error
                client, err = ssh.Dial("tcp", addr, sshConfig)
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">lastErr = err
                if attempt &lt; config.SSH.MaxRetries </span><span class="cov0" title="0">{
                        time.Sleep(config.SSH.RetryDelay)
                }</span>
        }

        <span class="cov0" title="0">if client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect after %d attempts: %w", config.SSH.MaxRetries+1, lastErr)
        }</span>

        <span class="cov0" title="0">return &amp;SSHConnection{
                Config:    config,
                Client:    client,
                LastUsed:  time.Now(),
                CreatedAt: time.Now(),
        }, nil</span>
}

// appendToKnownHosts appends a new host key to the known_hosts file
func appendToKnownHosts(filename, hostname string, key ssh.PublicKey) error <span class="cov2" title="2">{
        file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open known_hosts file: %w", err)
        }</span>
        <span class="cov2" title="2">defer file.Close()

        keyLine := fmt.Sprintf("%s %s\n", hostname, strings.TrimSpace(string(key.Marshal())))
        _, err = file.WriteString(keyLine)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to known_hosts file: %w", err)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// ExecuteCommand executes a command on a remote worker
func (conn *SSHConnection) ExecuteCommand(ctx context.Context, command string) ([]byte, error) <span class="cov1" title="1">{
        conn.mu.Lock()
        conn.LastUsed = time.Now()
        conn.mu.Unlock()

        session, err := conn.Client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>
        <span class="cov0" title="0">defer session.Close()

        // Execute command with context timeout
        done := make(chan []byte, 1)
        errChan := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                output, err := session.CombinedOutput(command)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">done &lt;- output</span>
        }()

        <span class="cov0" title="0">select </span>{
        case output := &lt;-done:<span class="cov0" title="0">
                return output, nil</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                session.Signal(ssh.SIGKILL)
                return nil, ctx.Err()</span>
        }
}

// Close closes the SSH connection
func (conn *SSHConnection) Close() error <span class="cov1" title="1">{
        conn.mu.Lock()
        defer conn.mu.Unlock()

        if conn.Client != nil </span><span class="cov0" title="0">{
                return conn.Client.Close()
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// GetWorkers returns all configured workers
func (p *SSHPool) GetWorkers() map[string]*WorkerConfig <span class="cov4" title="5">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        workers := make(map[string]*WorkerConfig)
        for id, config := range p.configs </span><span class="cov3" title="4">{
                workers[id] = config
        }</span>
        <span class="cov4" title="5">return workers</span>
}

// GetActiveConnections returns active connection count
func (p *SSHPool) GetActiveConnections() int <span class="cov2" title="2">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return len(p.connections)
}</span>

// cleanup periodically removes idle connections
func (p *SSHPool) cleanup() <span class="cov10" title="70">{
        ticker := time.NewTicker(p.cleanupTick)
        defer ticker.Stop()

        for </span><span class="cov10" title="70">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        p.mu.Lock()
                        now := time.Now()
                        for id, conn := range p.connections </span><span class="cov0" title="0">{
                                if now.Sub(conn.LastUsed) &gt; p.maxIdleTime </span><span class="cov0" title="0">{
                                        conn.Client.Close()
                                        delete(p.connections, id)
                                }</span>
                        }
                        <span class="cov0" title="0">p.mu.Unlock()</span>

                case &lt;-p.ctx.Done():<span class="cov8" title="37">
                        return</span>
                }
        }
}

// Close closes all connections and stops the pool
func (p *SSHPool) Close() <span class="cov8" title="37">{
        p.cancel()

        p.mu.Lock()
        defer p.mu.Unlock()

        for _, conn := range p.connections </span><span class="cov0" title="0">{
                conn.Client.Close()
        }</span>
        <span class="cov8" title="37">p.connections = make(map[string]*SSHConnection)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package distributed

import (
        "bytes"
        "context"
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/tls"
        "crypto/x509"
        "encoding/json"
        "encoding/pem"
        "fmt"
        "io"
        "net/http"
        "net/smtp"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "digital.vasic.translator/pkg/events"
)

// UpdateBackup represents a backup of a worker's state before an update
type UpdateBackup struct {
        WorkerID        string
        BackupID        string
        Timestamp       time.Time
        OriginalVersion VersionInfo
        BackupPath      string
        UpdatePackage   string
        Status          string // "created", "active", "rolled_back", "expired"
}

// SignedUpdatePackage represents a signed update package
type SignedUpdatePackage struct {
        PackagePath   string
        SignaturePath string
        PublicKeyPath string
        Version       string
        Timestamp     time.Time
}

// VersionMetrics represents version management metrics
type VersionMetrics struct {
        // Update metrics
        TotalUpdates      int64
        SuccessfulUpdates int64
        FailedUpdates     int64
        UpdateDuration    time.Duration
        LastUpdateTime    time.Time

        // Rollback metrics
        TotalRollbacks      int64
        SuccessfulRollbacks int64
        FailedRollbacks     int64
        RollbackDuration    time.Duration
        LastRollbackTime    time.Time

        // Version drift metrics
        WorkersChecked   int64
        WorkersUpToDate  int64
        WorkersOutdated  int64
        WorkersUnhealthy int64
        LastDriftCheck   time.Time
        MaxDriftDuration time.Duration

        // Security metrics
        SignatureVerifications int64
        SignatureSuccesses     int64
        SignatureFailures      int64
        KeyGenerations         int64

        // Backup metrics
        BackupsCreated     int64
        BackupsActive      int64
        BackupsExpired     int64
        BackupStorageBytes int64
}

// DriftAlert represents a version drift alert
type DriftAlert struct {
        WorkerID        string
        CurrentVersion  VersionInfo
        ExpectedVersion VersionInfo
        DriftDuration   time.Duration
        Severity        string // "low", "medium", "high", "critical"
        Timestamp       time.Time
        Message         string
        AlertID         string
        Acknowledged    bool
        AcknowledgedAt  *time.Time
        AcknowledgedBy  string
}

// AlertChannel represents an alert notification channel
type AlertChannel interface {
        SendAlert(alert *DriftAlert) error
        Name() string
}

// EmailAlertChannel sends alerts via email
type EmailAlertChannel struct {
        SMTPHost    string
        SMTPPort    int
        Username    string
        Password    string
        FromAddress string
        ToAddresses []string
}

// WebhookAlertChannel sends alerts via HTTP webhook
type WebhookAlertChannel struct {
        URL        string
        Method     string
        Headers    map[string]string
        HTTPClient *http.Client
}

// SlackAlertChannel sends alerts to Slack
type SlackAlertChannel struct {
        WebhookURL string
        Channel    string
        Username   string
        HTTPClient *http.Client
}

// AlertManager manages alert notifications
type AlertManager struct {
        channels     []AlertChannel
        alertHistory []*DriftAlert
        maxHistory   int
        mu           sync.RWMutex
}

// NewAlertManager creates a new alert manager
func NewAlertManager(maxHistory int) *AlertManager <span class="cov7" title="58">{
        if maxHistory &lt;= 0 </span><span class="cov1" title="1">{
                maxHistory = 1000
        }</span>

        <span class="cov7" title="58">return &amp;AlertManager{
                channels:     make([]AlertChannel, 0),
                alertHistory: make([]*DriftAlert, 0),
                maxHistory:   maxHistory,
        }</span>
}

// AddChannel adds an alert channel
func (am *AlertManager) AddChannel(channel AlertChannel) <span class="cov3" title="4">{
        am.mu.Lock()
        defer am.mu.Unlock()
        am.channels = append(am.channels, channel)
}</span>

// SendAlert sends an alert through all configured channels
func (am *AlertManager) SendAlert(alert *DriftAlert) error <span class="cov3" title="6">{
        am.mu.Lock()
        defer am.mu.Unlock()

        // Generate alert ID if not set
        if alert.AlertID == "" </span><span class="cov3" title="6">{
                alert.AlertID = fmt.Sprintf("alert-%d", time.Now().UnixNano())
        }</span>

        // Add to history
        <span class="cov3" title="6">am.alertHistory = append(am.alertHistory, alert)

        // Trim history if needed
        if len(am.alertHistory) &gt; am.maxHistory </span><span class="cov0" title="0">{
                am.alertHistory = am.alertHistory[len(am.alertHistory)-am.maxHistory:]
        }</span>

        // Send through all channels
        <span class="cov3" title="6">var lastErr error
        for _, channel := range am.channels </span><span class="cov1" title="1">{
                if err := channel.SendAlert(alert); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        // Log error but continue with other channels
                }</span>
        }

        <span class="cov3" title="6">return lastErr</span>
}

// GetAlertHistory returns alert history
func (am *AlertManager) GetAlertHistory(limit int) []*DriftAlert <span class="cov3" title="4">{
        am.mu.RLock()
        defer am.mu.RUnlock()

        if limit &lt;= 0 || limit &gt; len(am.alertHistory) </span><span class="cov2" title="3">{
                limit = len(am.alertHistory)
        }</span>

        // Return most recent alerts first
        <span class="cov3" title="4">result := make([]*DriftAlert, limit)
        copy(result, am.alertHistory[len(am.alertHistory)-limit:])
        return result</span>
}

// AcknowledgeAlert marks an alert as acknowledged
func (am *AlertManager) AcknowledgeAlert(alertID, acknowledgedBy string) bool <span class="cov3" title="4">{
        am.mu.Lock()
        defer am.mu.Unlock()

        for _, alert := range am.alertHistory </span><span class="cov2" title="3">{
                if alert.AlertID == alertID &amp;&amp; !alert.Acknowledged </span><span class="cov1" title="1">{
                        now := time.Now()
                        alert.Acknowledged = true
                        alert.AcknowledgedAt = &amp;now
                        alert.AcknowledgedBy = acknowledgedBy
                        return true
                }</span>
        }
        <span class="cov2" title="3">return false</span>
}

// EmailAlertChannel implementation
func (e *EmailAlertChannel) Name() string <span class="cov1" title="1">{
        return "email"
}</span>

func (e *EmailAlertChannel) SendAlert(alert *DriftAlert) error <span class="cov1" title="1">{
        subject := fmt.Sprintf("[%s] Version Drift Alert: %s", strings.ToUpper(alert.Severity), alert.WorkerID)

        body := fmt.Sprintf(`Version Drift Alert

Worker ID: %s
Severity: %s
Drift Duration: %v

Current Version: %s
Expected Version: %s

Message: %s

Timestamp: %s
Alert ID: %s

This is an automated alert from the version management system.
`,
                alert.WorkerID,
                alert.Severity,
                alert.DriftDuration,
                alert.CurrentVersion.CodebaseVersion,
                alert.ExpectedVersion.CodebaseVersion,
                alert.Message,
                alert.Timestamp.Format(time.RFC3339),
                alert.AlertID,
        )

        // Create email message
        message := fmt.Sprintf("From: %s\r\nTo: %s\r\nSubject: %s\r\n\r\n%s",
                e.FromAddress,
                strings.Join(e.ToAddresses, ","),
                subject,
                body,
        )

        // Send email
        auth := smtp.PlainAuth("", e.Username, e.Password, e.SMTPHost)
        addr := fmt.Sprintf("%s:%d", e.SMTPHost, e.SMTPPort)

        return smtp.SendMail(addr, auth, e.FromAddress, e.ToAddresses, []byte(message))
}</span>

// WebhookAlertChannel implementation
func (w *WebhookAlertChannel) Name() string <span class="cov1" title="1">{
        return "webhook"
}</span>

func (w *WebhookAlertChannel) SendAlert(alert *DriftAlert) error <span class="cov1" title="1">{
        if w.HTTPClient == nil </span><span class="cov1" title="1">{
                w.HTTPClient = &amp;http.Client{Timeout: 30 * time.Second}
        }</span>

        <span class="cov1" title="1">if w.Method == "" </span><span class="cov0" title="0">{
                w.Method = "POST"
        }</span>

        <span class="cov1" title="1">payload := map[string]interface{}{
                "alert_id":         alert.AlertID,
                "worker_id":        alert.WorkerID,
                "severity":         alert.Severity,
                "drift_duration":   alert.DriftDuration.String(),
                "current_version":  alert.CurrentVersion.CodebaseVersion,
                "expected_version": alert.ExpectedVersion.CodebaseVersion,
                "message":          alert.Message,
                "timestamp":        alert.Timestamp.Format(time.RFC3339),
                "acknowledged":     alert.Acknowledged,
        }

        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal alert payload: %w", err)
        }</span>

        <span class="cov1" title="1">req, err := http.NewRequest(w.Method, w.URL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create webhook request: %w", err)
        }</span>

        <span class="cov1" title="1">req.Header.Set("Content-Type", "application/json")
        for key, value := range w.Headers </span><span class="cov1" title="1">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov1" title="1">resp, err := w.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send webhook: %w", err)
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("webhook returned status %d", resp.StatusCode)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// SlackAlertChannel implementation
func (s *SlackAlertChannel) Name() string <span class="cov1" title="1">{
        return "slack"
}</span>

func (s *SlackAlertChannel) SendAlert(alert *DriftAlert) error <span class="cov1" title="1">{
        if s.HTTPClient == nil </span><span class="cov1" title="1">{
                s.HTTPClient = &amp;http.Client{Timeout: 30 * time.Second}
        }</span>

        <span class="cov1" title="1">if s.Username == "" </span><span class="cov1" title="1">{
                s.Username = "Version Monitor"
        }</span>

        <span class="cov1" title="1">color := "good"
        switch alert.Severity </span>{
        case "low":<span class="cov0" title="0">
                color = "good"</span>
        case "medium":<span class="cov0" title="0">
                color = "warning"</span>
        case "high":<span class="cov0" title="0">
                color = "danger"</span>
        case "critical":<span class="cov0" title="0">
                color = "#FF0000"</span>
        }

        <span class="cov1" title="1">payload := map[string]interface{}{
                "channel":  s.Channel,
                "username": s.Username,
                "attachments": []map[string]interface{}{
                        {
                                "color": color,
                                "title": fmt.Sprintf("Version Drift Alert - %s", strings.ToUpper(alert.Severity)),
                                "fields": []map[string]interface{}{
                                        {
                                                "title": "Worker ID",
                                                "value": alert.WorkerID,
                                                "short": true,
                                        },
                                        {
                                                "title": "Drift Duration",
                                                "value": alert.DriftDuration.String(),
                                                "short": true,
                                        },
                                        {
                                                "title": "Current Version",
                                                "value": alert.CurrentVersion.CodebaseVersion,
                                                "short": true,
                                        },
                                        {
                                                "title": "Expected Version",
                                                "value": alert.ExpectedVersion.CodebaseVersion,
                                                "short": true,
                                        },
                                },
                                "text":   alert.Message,
                                "footer": fmt.Sprintf("Alert ID: %s", alert.AlertID),
                                "ts":     alert.Timestamp.Unix(),
                        },
                },
        }

        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal Slack payload: %w", err)
        }</span>

        <span class="cov1" title="1">req, err := http.NewRequest("POST", s.WebhookURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Slack request: %w", err)
        }</span>

        <span class="cov1" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := s.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send Slack message: %w", err)
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov1" title="1">{
                return fmt.Errorf("Slack webhook returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// VersionCacheEntry represents a cached version check result
type VersionCacheEntry struct {
        VersionInfo VersionInfo
        Timestamp   time.Time
        TTL         time.Duration
}

// VersionManager handles version checking, updates, and validation for remote workers
type VersionManager struct {
        localVersion VersionInfo
        httpClient   *http.Client
        eventBus     *events.EventBus
        updateDir    string
        backupDir    string
        backups      map[string]*UpdateBackup // workerID -&gt; backup
        metrics      *VersionMetrics
        alerts       []*DriftAlert
        alertManager *AlertManager
        versionCache map[string]*VersionCacheEntry // workerID -&gt; cached version info
        cacheTTL     time.Duration
        baseURL      string // For testing: override the URL construction
}

// NewVersionManager creates a new version manager
func NewVersionManager(eventBus *events.EventBus) *VersionManager <span class="cov7" title="51">{
        // Get local version information
        localVersion := getLocalVersionInfo()

        // Create HTTP client for version checks and downloads
        httpClient := &amp;http.Client{
                Timeout: 30 * time.Second,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
                },
        }

        return &amp;VersionManager{
                localVersion: localVersion,
                httpClient:   httpClient,
                eventBus:     eventBus,
                updateDir:    "/tmp/translator-updates",
                backupDir:    "/tmp/translator-backups",
                backups:      make(map[string]*UpdateBackup),
                metrics:      &amp;VersionMetrics{},
                alerts:       make([]*DriftAlert, 0),
                alertManager: NewAlertManager(1000),
                versionCache: make(map[string]*VersionCacheEntry),
                cacheTTL:     5 * time.Minute, // Cache version checks for 5 minutes
        }
}</span>

// getLocalVersionInfo retrieves version information for the local codebase
func getLocalVersionInfo() VersionInfo <span class="cov7" title="51">{
        version := VersionInfo{
                CodebaseVersion: getCodebaseVersion(),
                BuildTime:       getBuildTime(),
                GitCommit:       getGitCommit(),
                GoVersion:       getGoVersion(),
                Components:      make(map[string]string),
                LastUpdated:     time.Now(),
        }

        // Add component versions
        version.Components["translator"] = version.CodebaseVersion
        version.Components["api"] = "1.0.0"
        version.Components["distributed"] = "1.0.0"
        version.Components["deployment"] = "1.0.0"

        return version
}</span>

// getCodebaseVersion returns the current codebase version
func getCodebaseVersion() string <span class="cov7" title="51">{
        // Try to read from version file first
        if version, err := readVersionFile("VERSION"); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(version)
        }</span>

        // Try git describe
        <span class="cov7" title="51">if version, err := runCommand("git", "describe", "--tags", "--abbrev=0"); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(version)
        }</span>

        // Try git rev-parse
        <span class="cov7" title="51">if commit, err := runCommand("git", "rev-parse", "--short", "HEAD"); err == nil </span><span class="cov7" title="51">{
                return fmt.Sprintf("dev-%s", strings.TrimSpace(commit))
        }</span>

        <span class="cov0" title="0">return "unknown"</span>
}

// getBuildTime returns the build timestamp
func getBuildTime() string <span class="cov7" title="51">{
        if buildTime, err := runCommand("date", "-u", "+%Y-%m-%dT%H:%M:%SZ"); err == nil </span><span class="cov7" title="51">{
                return strings.TrimSpace(buildTime)
        }</span>
        <span class="cov0" title="0">return time.Now().UTC().Format(time.RFC3339)</span>
}

// getGitCommit returns the current git commit hash
func getGitCommit() string <span class="cov7" title="51">{
        if commit, err := runCommand("git", "rev-parse", "HEAD"); err == nil </span><span class="cov7" title="51">{
                return strings.TrimSpace(commit)
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// getGoVersion returns the Go version used to build
func getGoVersion() string <span class="cov7" title="51">{
        if version, err := runCommand("go", "version"); err == nil </span><span class="cov7" title="51">{
                parts := strings.Split(version, " ")
                if len(parts) &gt;= 3 </span><span class="cov7" title="51">{
                        return parts[2]
                }</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}

// readVersionFile reads version from a file
func readVersionFile(filename string) (string, error) <span class="cov7" title="51">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov7" title="51">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(data), nil</span>
}

// runCommand executes a shell command and returns its output
func runCommand(name string, args ...string) (string, error) <span class="cov10" title="255">{
        cmd := exec.Command(name, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov7" title="51">{
                return "", err
        }</span>
        <span class="cov9" title="204">return string(output), nil</span>
}

// SetBaseURL sets the base URL for testing purposes
func (vm *VersionManager) SetBaseURL(baseURL string) <span class="cov0" title="0">{
        vm.baseURL = baseURL
}</span>

// CheckWorkerVersion checks if a worker's version matches the local version
func (vm *VersionManager) CheckWorkerVersion(ctx context.Context, service *RemoteService) (bool, error) <span class="cov5" title="19">{
        // Check cache first
        if cached, exists := vm.versionCache[service.WorkerID]; exists &amp;&amp; time.Since(cached.Timestamp) &lt; cached.TTL </span><span class="cov0" title="0">{
                // Use cached version
                service.Version = cached.VersionInfo
                isUpToDate := vm.compareVersions(vm.localVersion, cached.VersionInfo)

                // Emit cached event
                event := events.Event{
                        Type:      "worker_version_checked_cached",
                        SessionID: "system",
                        Timestamp: time.Now(),
                        Data: map[string]interface{}{
                                "worker_id":      service.WorkerID,
                                "local_version":  vm.localVersion.CodebaseVersion,
                                "worker_version": cached.VersionInfo.CodebaseVersion,
                                "up_to_date":     isUpToDate,
                                "cached":         true,
                        },
                }
                vm.eventBus.Publish(event)

                return isUpToDate, nil
        }</span>

        // Query worker for its version
        <span class="cov5" title="18">var versionURL string
        if vm.baseURL != "" </span><span class="cov0" title="0">{
                versionURL = vm.baseURL + "/api/v1/version"
        }</span> else<span class="cov5" title="18"> {
                versionURL = fmt.Sprintf("%s://%s:%d/api/v1/version", service.Protocol, service.Host, service.Port)
        }</span>

        <span class="cov5" title="18">req, err := http.NewRequestWithContext(ctx, "GET", versionURL, nil)
        if err != nil </span><span class="cov2" title="2">{
                return false, fmt.Errorf("failed to create version request: %w", err)
        }</span>

        <span class="cov5" title="16">resp, err := vm.httpClient.Do(req)
        if err != nil </span><span class="cov5" title="16">{
                return false, fmt.Errorf("failed to query worker version: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return false, fmt.Errorf("worker version endpoint returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var workerVersion VersionInfo
        if err := json.NewDecoder(resp.Body).Decode(&amp;workerVersion); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to decode worker version: %w", err)
        }</span>

        // Update cache
        <span class="cov0" title="0">vm.versionCache[service.WorkerID] = &amp;VersionCacheEntry{
                VersionInfo: workerVersion,
                Timestamp:   time.Now(),
                TTL:         vm.cacheTTL,
        }

        // Update service with version info
        service.Version = workerVersion

        // Compare versions
        isUpToDate := vm.compareVersions(vm.localVersion, workerVersion)

        // Record metrics
        if isUpToDate </span>{<span class="cov0" title="0">
                // This will be counted in drift detection
        }</span> else <span class="cov0" title="0">{
                // Could add per-worker metrics here if needed
        }</span>

        // Emit event
        <span class="cov0" title="0">event := events.Event{
                Type:      "worker_version_checked",
                SessionID: "system",
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "worker_id":      service.WorkerID,
                        "local_version":  vm.localVersion.CodebaseVersion,
                        "worker_version": workerVersion.CodebaseVersion,
                        "up_to_date":     isUpToDate,
                        "cached":         false,
                },
        }
        vm.eventBus.Publish(event)

        return isUpToDate, nil</span>
}

// compareVersions compares two version infos
func (vm *VersionManager) compareVersions(local, remote VersionInfo) bool <span class="cov0" title="0">{
        // Compare codebase versions
        if local.CodebaseVersion != remote.CodebaseVersion </span><span class="cov0" title="0">{
                return false
        }</span>

        // Compare critical components
        <span class="cov0" title="0">criticalComponents := []string{"translator", "api", "distributed"}
        for _, component := range criticalComponents </span><span class="cov0" title="0">{
                if local.Components[component] != remote.Components[component] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// UpdateWorker updates a worker to the latest version
func (vm *VersionManager) UpdateWorker(ctx context.Context, service *RemoteService) error <span class="cov0" title="0">{
        return vm.UpdateWorkerWithSigning(ctx, service, "", "")
}</span>

// UpdateWorkerWithSigning updates a worker with optional signature verification
func (vm *VersionManager) UpdateWorkerWithSigning(ctx context.Context, service *RemoteService, privateKeyPath, expectedPublicKeyPath string) error <span class="cov0" title="0">{
        service.Status = "updating"

        // Emit update started event
        event := events.Event{
                Type:      "worker_update_started",
                SessionID: "system",
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "worker_id":         service.WorkerID,
                        "target_version":    vm.localVersion.CodebaseVersion,
                        "current_version":   service.Version.CodebaseVersion,
                        "signature_enabled": privateKeyPath != "",
                },
        }
        vm.eventBus.Publish(event)

        // Create backup before starting update
        backup, err := vm.createWorkerBackup(ctx, service)
        if err != nil </span><span class="cov0" title="0">{
                service.Status = "outdated"
                return fmt.Errorf("failed to create backup: %w", err)
        }</span>
        <span class="cov0" title="0">backup.Status = "active"

        var updatePackage string
        var signedPackage *SignedUpdatePackage

        // Create update package (signed or unsigned)
        if privateKeyPath != "" </span><span class="cov0" title="0">{
                signedPackage, err = vm.createSignedUpdatePackage(privateKeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        vm.rollbackWorkerUpdate(ctx, service) // Rollback on failure
                        return fmt.Errorf("failed to create signed update package: %w", err)
                }</span>
                <span class="cov0" title="0">updatePackage = signedPackage.PackagePath
                backup.UpdatePackage = updatePackage</span>
        } else<span class="cov0" title="0"> {
                updatePackage, err = vm.createUpdatePackage()
                if err != nil </span><span class="cov0" title="0">{
                        vm.rollbackWorkerUpdate(ctx, service) // Rollback on failure
                        return fmt.Errorf("failed to create update package: %w", err)
                }</span>
                <span class="cov0" title="0">backup.UpdatePackage = updatePackage</span>
        }

        // Upload update package to worker
        <span class="cov0" title="0">if err := vm.uploadUpdatePackage(ctx, service, updatePackage); err != nil </span><span class="cov0" title="0">{
                vm.rollbackWorkerUpdate(ctx, service) // Rollback on failure
                return fmt.Errorf("failed to upload update package: %w", err)
        }</span>

        // Upload signature and public key if signed
        <span class="cov0" title="0">if signedPackage != nil </span><span class="cov0" title="0">{
                if err := vm.uploadSignatureFiles(ctx, service, signedPackage); err != nil </span><span class="cov0" title="0">{
                        vm.rollbackWorkerUpdate(ctx, service) // Rollback on failure
                        return fmt.Errorf("failed to upload signature files: %w", err)
                }</span>
        }

        // Trigger update on worker
        <span class="cov0" title="0">if err := vm.triggerWorkerUpdate(ctx, service); err != nil </span><span class="cov0" title="0">{
                vm.rollbackWorkerUpdate(ctx, service) // Rollback on failure
                return fmt.Errorf("failed to trigger worker update: %w", err)
        }</span>

        // Wait for update completion
        <span class="cov0" title="0">if err := vm.waitForUpdateCompletion(ctx, service); err != nil </span><span class="cov0" title="0">{
                vm.rollbackWorkerUpdate(ctx, service) // Rollback on failure
                return fmt.Errorf("update failed to complete: %w", err)
        }</span>

        // Verify update
        <span class="cov0" title="0">if upToDate, err := vm.CheckWorkerVersion(ctx, service); err != nil || !upToDate </span><span class="cov0" title="0">{
                vm.rollbackWorkerUpdate(ctx, service) // Rollback on failure
                return fmt.Errorf("update verification failed")
        }</span>

        <span class="cov0" title="0">service.Status = "paired"

        // Mark backup as completed (no longer active)
        backup.Status = "completed"

        // Emit update completed event
        event = events.Event{
                Type:      "worker_update_completed",
                SessionID: "system",
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "worker_id": service.WorkerID,
                        "version":   vm.localVersion.CodebaseVersion,
                        "signed":    signedPackage != nil,
                },
        }
        vm.eventBus.Publish(event)

        return nil</span>
}

// createUpdatePackage creates a compressed package of the current codebase
func (vm *VersionManager) createUpdatePackage() (string, error) <span class="cov0" title="0">{
        // Ensure update directory exists
        if err := os.MkdirAll(vm.updateDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create update directory: %w", err)
        }</span>

        // Create package filename
        <span class="cov0" title="0">packageName := fmt.Sprintf("translator-update-%s-%d.tar.gz",
                vm.localVersion.CodebaseVersion, time.Now().Unix())

        packagePath := filepath.Join(vm.updateDir, packageName)

        // Create tar.gz archive of current directory (excluding .git, build, etc.)
        cmd := exec.Command("tar", "-czf", packagePath, "--exclude=.git", "--exclude=build",
                "--exclude=node_modules", "--exclude=.DS_Store", ".")
        cmd.Dir = "." // Current directory

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create update package: %w", err)
        }</span>

        <span class="cov0" title="0">return packagePath, nil</span>
}

// uploadUpdatePackage uploads the update package to the worker
func (vm *VersionManager) uploadUpdatePackage(ctx context.Context, service *RemoteService, packagePath string) error <span class="cov0" title="0">{
        var uploadURL string
        if vm.baseURL != "" </span><span class="cov0" title="0">{
                uploadURL = vm.baseURL + "/api/v1/update/upload"
        }</span> else<span class="cov0" title="0"> {
                uploadURL = fmt.Sprintf("%s://%s:%d/api/v1/update/upload", service.Protocol, service.Host, service.Port)
        }</span>

        <span class="cov0" title="0">file, err := os.Open(packagePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open update package: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        req, err := http.NewRequestWithContext(ctx, "POST", uploadURL, file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create upload request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/octet-stream")
        req.Header.Set("X-Update-Version", vm.localVersion.CodebaseVersion)

        resp, err := vm.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload update package: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("upload failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// triggerWorkerUpdate triggers the update process on the worker
func (vm *VersionManager) triggerWorkerUpdate(ctx context.Context, service *RemoteService) error <span class="cov0" title="0">{
        var updateURL string
        if vm.baseURL != "" </span><span class="cov0" title="0">{
                updateURL = vm.baseURL + "/api/v1/update/apply"
        }</span> else<span class="cov0" title="0"> {
                updateURL = fmt.Sprintf("%s://%s:%d/api/v1/update/apply", service.Protocol, service.Host, service.Port)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", updateURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create update request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("X-Update-Version", vm.localVersion.CodebaseVersion)

        resp, err := vm.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to trigger update: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("update trigger failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// waitForUpdateCompletion waits for the worker update to complete
func (vm *VersionManager) waitForUpdateCompletion(ctx context.Context, service *RemoteService) error <span class="cov0" title="0">{
        timeout := time.After(5 * time.Minute)
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        return fmt.Errorf("update timeout")</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Check if worker is back online and updated
                        if upToDate, err := vm.CheckWorkerVersion(ctx, service); err == nil &amp;&amp; upToDate </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
}

// ValidateWorkerForWork validates that a worker is ready for work (up to date and healthy)
func (vm *VersionManager) ValidateWorkerForWork(ctx context.Context, service *RemoteService) error <span class="cov0" title="0">{
        // Check version
        upToDate, err := vm.CheckWorkerVersion(ctx, service)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("version check failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !upToDate </span><span class="cov0" title="0">{
                return fmt.Errorf("worker %s is outdated (local: %s, worker: %s)",
                        service.WorkerID, vm.localVersion.CodebaseVersion, service.Version.CodebaseVersion)
        }</span>

        // Check health
        <span class="cov0" title="0">var healthURL string
        if vm.baseURL != "" </span><span class="cov0" title="0">{
                healthURL = vm.baseURL + "/health"
        }</span> else<span class="cov0" title="0"> {
                healthURL = fmt.Sprintf("%s://%s:%d/health", service.Protocol, service.Host, service.Port)
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "GET", healthURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create health check request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := vm.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("worker health check failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createWorkerBackup creates a backup of the worker's current state before update
func (vm *VersionManager) createWorkerBackup(ctx context.Context, service *RemoteService) (*UpdateBackup, error) <span class="cov0" title="0">{
        // Ensure backup directory exists
        if err := os.MkdirAll(vm.backupDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create backup directory: %w", err)
        }</span>

        <span class="cov0" title="0">backupID := fmt.Sprintf("backup-%s-%d", service.WorkerID, time.Now().Unix())
        backupPath := filepath.Join(vm.backupDir, backupID)

        // Create backup directory
        if err := os.MkdirAll(backupPath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create backup path: %w", err)
        }</span>

        <span class="cov0" title="0">backup := &amp;UpdateBackup{
                WorkerID:        service.WorkerID,
                BackupID:        backupID,
                Timestamp:       time.Now(),
                OriginalVersion: service.Version,
                BackupPath:      backupPath,
                Status:          "created",
        }

        // Store backup reference
        vm.backups[service.WorkerID] = backup

        // Emit backup created event
        event := events.Event{
                Type:      "worker_backup_created",
                SessionID: "system",
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "worker_id":        service.WorkerID,
                        "backup_id":        backupID,
                        "original_version": service.Version.CodebaseVersion,
                },
        }
        vm.eventBus.Publish(event)

        return backup, nil</span>
}

// rollbackWorkerUpdate rolls back a worker to its previous state using the backup
func (vm *VersionManager) rollbackWorkerUpdate(ctx context.Context, service *RemoteService) error <span class="cov1" title="1">{
        backup, exists := vm.backups[service.WorkerID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("no backup found for worker %s", service.WorkerID)
        }</span>

        <span class="cov0" title="0">if backup.Status != "active" </span><span class="cov0" title="0">{
                return fmt.Errorf("backup %s is not active (status: %s)", backup.BackupID, backup.Status)
        }</span>

        // Emit rollback started event
        <span class="cov0" title="0">event := events.Event{
                Type:      "worker_rollback_started",
                SessionID: "system",
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "worker_id":    service.WorkerID,
                        "backup_id":    backup.BackupID,
                        "from_version": service.Version.CodebaseVersion,
                        "to_version":   backup.OriginalVersion.CodebaseVersion,
                },
        }
        vm.eventBus.Publish(event)

        // Trigger rollback on worker
        var rollbackURL string
        if vm.baseURL != "" </span><span class="cov0" title="0">{
                rollbackURL = vm.baseURL + "/api/v1/update/rollback"
        }</span> else<span class="cov0" title="0"> {
                rollbackURL = fmt.Sprintf("%s://%s:%d/api/v1/update/rollback", service.Protocol, service.Host, service.Port)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", rollbackURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create rollback request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("X-Backup-ID", backup.BackupID)

        resp, err := vm.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to trigger rollback: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("rollback failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Wait for rollback completion
        <span class="cov0" title="0">if err := vm.waitForRollbackCompletion(ctx, service, backup); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rollback failed to complete: %w", err)
        }</span>

        // Restore original version info
        <span class="cov0" title="0">service.Version = backup.OriginalVersion
        service.Status = "paired"

        // Mark backup as rolled back
        backup.Status = "rolled_back"

        // Emit rollback completed event
        event = events.Event{
                Type:      "worker_rollback_completed",
                SessionID: "system",
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "worker_id": service.WorkerID,
                        "backup_id": backup.BackupID,
                        "version":   backup.OriginalVersion.CodebaseVersion,
                },
        }
        vm.eventBus.Publish(event)

        return nil</span>
}

// waitForRollbackCompletion waits for the worker rollback to complete
func (vm *VersionManager) waitForRollbackCompletion(ctx context.Context, service *RemoteService, backup *UpdateBackup) error <span class="cov0" title="0">{
        timeout := time.After(2 * time.Minute)
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        return fmt.Errorf("rollback timeout")</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Check if worker has rolled back to original version
                        if _, err := vm.CheckWorkerVersion(ctx, service); err == nil </span><span class="cov0" title="0">{
                                if service.Version.CodebaseVersion == backup.OriginalVersion.CodebaseVersion </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                }
        }
}

// cleanupExpiredBackups removes old backups that are no longer needed
func (vm *VersionManager) cleanupExpiredBackups() error <span class="cov0" title="0">{
        // Remove backups older than 24 hours that are not active
        cutoff := time.Now().Add(-24 * time.Hour)

        for workerID, backup := range vm.backups </span><span class="cov0" title="0">{
                if backup.Timestamp.Before(cutoff) &amp;&amp; backup.Status != "active" </span><span class="cov0" title="0">{
                        if err := os.RemoveAll(backup.BackupPath); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue cleanup
                                fmt.Printf("Failed to remove backup %s: %v\n", backup.BackupPath, err)
                        }</span>
                        <span class="cov0" title="0">delete(vm.backups, workerID)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetLocalVersion returns the local version information
func (vm *VersionManager) GetLocalVersion() VersionInfo <span class="cov0" title="0">{
        return vm.localVersion
}</span>

// InstallWorker performs initial installation on a new worker
func (vm *VersionManager) InstallWorker(ctx context.Context, workerID, host string, port int) error <span class="cov0" title="0">{
        // Simplified worker installation process
        // In a real implementation, this would:
        // 1. Test connectivity to worker
        // 2. Transfer binaries via SCP/SFTP
        // 3. Install dependencies
        // 4. Configure service
        // 5. Verify installation

        // For now, simulate the installation process
        installSteps := []string{
                "checking_connectivity",
                "transferring_binaries",
                "installing_dependencies",
                "configuring_service",
                "verifying_installation",
        }

        for _, step := range installSteps </span><span class="cov0" title="0">{
                // Simulate step execution time
                select </span>{
                case &lt;-time.After(1 * time.Second):<span class="cov0" title="0"></span>
                        // Continue with next step
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("installation cancelled during step: %s", step)</span>
                }
        }

        // Record installation in metrics (simplified - just increment a counter)
        // Note: In real implementation, this would update proper metrics

        <span class="cov0" title="0">return nil</span>
}

// GetMetrics returns current version management metrics
func (vm *VersionManager) GetMetrics() *VersionMetrics <span class="cov1" title="1">{
        return vm.metrics
}</span>

// GetAlerts returns current version drift alerts
func (vm *VersionManager) GetAlerts() []*DriftAlert <span class="cov1" title="1">{
        return vm.alerts
}</span>

// AddAlertChannel adds an alert notification channel
func (vm *VersionManager) AddAlertChannel(channel AlertChannel) <span class="cov1" title="1">{
        vm.alertManager.AddChannel(channel)
}</span>

// BatchUpdateWorkers performs concurrent updates on multiple workers
func (vm *VersionManager) BatchUpdateWorkers(ctx context.Context, services []*RemoteService, maxConcurrency int) *BatchUpdateResult <span class="cov0" title="0">{
        if maxConcurrency &lt;= 0 </span><span class="cov0" title="0">{
                maxConcurrency = 3 // Default concurrency
        }</span>

        <span class="cov0" title="0">result := &amp;BatchUpdateResult{
                TotalWorkers: len(services),
                Successful:   make([]string, 0),
                Failed:       make([]BatchUpdateError, 0),
                Skipped:      make([]string, 0),
                StartTime:    time.Now(),
        }

        // Use semaphore to limit concurrency
        semaphore := make(chan struct{}, maxConcurrency)
        var wg sync.WaitGroup
        var mu sync.Mutex

        for _, service := range services </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(svc *RemoteService) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Acquire semaphore
                        semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()

                        // Check if already up to date first
                        <span class="cov0" title="0">upToDate, err := vm.CheckWorkerVersion(ctx, svc)
                        if err != nil </span><span class="cov0" title="0">{
                                mu.Lock()
                                result.Failed = append(result.Failed, BatchUpdateError{
                                        WorkerID: svc.WorkerID,
                                        Error:    fmt.Sprintf("version check failed: %v", err),
                                })
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">if upToDate </span><span class="cov0" title="0">{
                                mu.Lock()
                                result.Skipped = append(result.Skipped, svc.WorkerID)
                                mu.Unlock()
                                return
                        }</span>

                        // Perform update
                        <span class="cov0" title="0">if err := vm.UpdateWorker(ctx, svc); err != nil </span><span class="cov0" title="0">{
                                mu.Lock()
                                result.Failed = append(result.Failed, BatchUpdateError{
                                        WorkerID: svc.WorkerID,
                                        Error:    fmt.Sprintf("update failed: %v", err),
                                })
                                mu.Unlock()
                                return
                        }</span>

                        // Success
                        <span class="cov0" title="0">mu.Lock()
                        result.Successful = append(result.Successful, svc.WorkerID)
                        mu.Unlock()</span>
                }(service)
        }

        <span class="cov0" title="0">wg.Wait()
        result.EndTime = time.Now()
        result.Duration = result.EndTime.Sub(result.StartTime)

        return result</span>
}

// BatchUpdateResult contains the results of a batch update operation
type BatchUpdateResult struct {
        TotalWorkers int
        Successful   []string
        Failed       []BatchUpdateError
        Skipped      []string
        StartTime    time.Time
        EndTime      time.Time
        Duration     time.Duration
}

// BatchUpdateError represents an error that occurred during batch update
type BatchUpdateError struct {
        WorkerID string
        Error    string
}

// GetSuccessRate returns the success rate as a percentage
func (r *BatchUpdateResult) GetSuccessRate() float64 <span class="cov0" title="0">{
        if r.TotalWorkers == 0 </span><span class="cov0" title="0">{
                return 100.0
        }</span>
        <span class="cov0" title="0">return float64(len(r.Successful)) / float64(r.TotalWorkers) * 100.0</span>
}

// GetSummary returns a summary string of the batch update results
func (r *BatchUpdateResult) GetSummary() string <span class="cov0" title="0">{
        return fmt.Sprintf("Batch update completed: %d/%d successful (%.1f%%), %d failed, %d skipped in %v",
                len(r.Successful), r.TotalWorkers, r.GetSuccessRate(), len(r.Failed), len(r.Skipped), r.Duration)
}</span>

// ClearCache clears the version check cache
func (vm *VersionManager) ClearCache() <span class="cov0" title="0">{
        vm.versionCache = make(map[string]*VersionCacheEntry)
}</span>

// SetCacheTTL sets the cache TTL for version checks
func (vm *VersionManager) SetCacheTTL(ttl time.Duration) <span class="cov0" title="0">{
        if ttl &gt; 0 </span><span class="cov0" title="0">{
                vm.cacheTTL = ttl
        }</span>
}

// GetCacheStats returns cache statistics
func (vm *VersionManager) GetCacheStats() map[string]interface{} <span class="cov0" title="0">{
        totalEntries := len(vm.versionCache)
        now := time.Now()
        validEntries := 0
        expiredEntries := 0

        for _, entry := range vm.versionCache </span><span class="cov0" title="0">{
                if now.Sub(entry.Timestamp) &lt; entry.TTL </span><span class="cov0" title="0">{
                        validEntries++
                }</span> else<span class="cov0" title="0"> {
                        expiredEntries++
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "total_entries":   totalEntries,
                "valid_entries":   validEntries,
                "expired_entries": expiredEntries,
                "cache_ttl":       vm.cacheTTL.String(),
                "hit_rate":        "N/A", // Would need hit/miss counters to calculate
        }</span>
}

// GetAlertHistory returns alert history with optional limit
func (vm *VersionManager) GetAlertHistory(limit int) []*DriftAlert <span class="cov1" title="1">{
        return vm.alertManager.GetAlertHistory(limit)
}</span>

// AcknowledgeAlert marks an alert as acknowledged
func (vm *VersionManager) AcknowledgeAlert(alertID, acknowledgedBy string) bool <span class="cov1" title="1">{
        return vm.alertManager.AcknowledgeAlert(alertID, acknowledgedBy)
}</span>

// CheckVersionDrift performs comprehensive version drift detection across all workers
func (vm *VersionManager) CheckVersionDrift(ctx context.Context, services []*RemoteService) []*DriftAlert <span class="cov1" title="1">{
        alerts := make([]*DriftAlert, 0)
        now := time.Now()

        vm.metrics.LastDriftCheck = now
        vm.metrics.WorkersChecked = int64(len(services))

        upToDateCount := int64(0)
        outdatedCount := int64(0)
        unhealthyCount := int64(0)

        for _, service := range services </span><span class="cov0" title="0">{
                // Check version
                isUpToDate, err := vm.CheckWorkerVersion(ctx, service)
                if err != nil </span><span class="cov0" title="0">{
                        unhealthyCount++
                        alert := &amp;DriftAlert{
                                WorkerID:        service.WorkerID,
                                CurrentVersion:  service.Version,
                                ExpectedVersion: vm.localVersion,
                                DriftDuration:   time.Since(service.LastSeen),
                                Severity:        "high",
                                Timestamp:       now,
                                Message:         fmt.Sprintf("Worker %s is unreachable: %v", service.WorkerID, err),
                        }
                        alerts = append(alerts, alert)
                        continue</span>
                }

                <span class="cov0" title="0">if isUpToDate </span><span class="cov0" title="0">{
                        upToDateCount++
                }</span> else<span class="cov0" title="0"> {
                        outdatedCount++

                        // Calculate drift duration
                        driftDuration := now.Sub(service.Version.LastUpdated)
                        if driftDuration &gt; vm.metrics.MaxDriftDuration </span><span class="cov0" title="0">{
                                vm.metrics.MaxDriftDuration = driftDuration
                        }</span>

                        // Determine severity based on drift duration
                        <span class="cov0" title="0">severity := vm.calculateDriftSeverity(driftDuration)

                        alert := &amp;DriftAlert{
                                WorkerID:        service.WorkerID,
                                CurrentVersion:  service.Version,
                                ExpectedVersion: vm.localVersion,
                                DriftDuration:   driftDuration,
                                Severity:        severity,
                                Timestamp:       now,
                                Message: fmt.Sprintf("Worker %s is running version %s, expected %s (drift: %v)",
                                        service.WorkerID, service.Version.CodebaseVersion,
                                        vm.localVersion.CodebaseVersion, driftDuration),
                        }
                        alerts = append(alerts, alert)

                        // Send alert through alert manager
                        if err := vm.alertManager.SendAlert(alert); err != nil </span><span class="cov0" title="0">{
                                // Log error but don't fail the drift check
                                fmt.Printf("Failed to send alert for worker %s: %v\n", service.WorkerID, err)
                        }</span>
                }
        }

        // Update metrics
        <span class="cov1" title="1">vm.metrics.WorkersUpToDate = upToDateCount
        vm.metrics.WorkersOutdated = outdatedCount
        vm.metrics.WorkersUnhealthy = unhealthyCount

        // Store alerts
        vm.alerts = alerts

        // Emit drift check event
        event := events.Event{
                Type:      "version_drift_check_completed",
                SessionID: "system",
                Timestamp: now,
                Data: map[string]interface{}{
                        "workers_checked":    vm.metrics.WorkersChecked,
                        "workers_up_to_date": vm.metrics.WorkersUpToDate,
                        "workers_outdated":   vm.metrics.WorkersOutdated,
                        "workers_unhealthy":  vm.metrics.WorkersUnhealthy,
                        "alerts_generated":   len(alerts),
                },
        }
        vm.eventBus.Publish(event)

        return alerts</span>
}

// calculateDriftSeverity determines alert severity based on drift duration
func (vm *VersionManager) calculateDriftSeverity(driftDuration time.Duration) string <span class="cov0" title="0">{
        switch </span>{
        case driftDuration &gt; 24*time.Hour:<span class="cov0" title="0">
                return "critical"</span>
        case driftDuration &gt; 12*time.Hour:<span class="cov0" title="0">
                return "high"</span>
        case driftDuration &gt; 6*time.Hour:<span class="cov0" title="0">
                return "medium"</span>
        default:<span class="cov0" title="0">
                return "low"</span>
        }
}

// RecordUpdateMetrics records metrics for a completed update operation
func (vm *VersionManager) RecordUpdateMetrics(success bool, duration time.Duration) <span class="cov0" title="0">{
        vm.metrics.TotalUpdates++
        vm.metrics.LastUpdateTime = time.Now()

        if success </span><span class="cov0" title="0">{
                vm.metrics.SuccessfulUpdates++
        }</span> else<span class="cov0" title="0"> {
                vm.metrics.FailedUpdates++
        }</span>

        // Update average duration (simple moving average)
        <span class="cov0" title="0">if vm.metrics.UpdateDuration == 0 </span><span class="cov0" title="0">{
                vm.metrics.UpdateDuration = duration
        }</span> else<span class="cov0" title="0"> {
                // Weighted average favoring recent measurements
                vm.metrics.UpdateDuration = (vm.metrics.UpdateDuration + duration) / 2
        }</span>
}

// RecordRollbackMetrics records metrics for a completed rollback operation
func (vm *VersionManager) RecordRollbackMetrics(success bool, duration time.Duration) <span class="cov0" title="0">{
        vm.metrics.TotalRollbacks++
        vm.metrics.LastRollbackTime = time.Now()

        if success </span><span class="cov0" title="0">{
                vm.metrics.SuccessfulRollbacks++
        }</span> else<span class="cov0" title="0"> {
                vm.metrics.FailedRollbacks++
        }</span>

        // Update average duration
        <span class="cov0" title="0">if vm.metrics.RollbackDuration == 0 </span><span class="cov0" title="0">{
                vm.metrics.RollbackDuration = duration
        }</span> else<span class="cov0" title="0"> {
                vm.metrics.RollbackDuration = (vm.metrics.RollbackDuration + duration) / 2
        }</span>
}

// RecordSignatureMetrics records metrics for signature operations
func (vm *VersionManager) RecordSignatureMetrics(success bool) <span class="cov0" title="0">{
        vm.metrics.SignatureVerifications++

        if success </span><span class="cov0" title="0">{
                vm.metrics.SignatureSuccesses++
        }</span> else<span class="cov0" title="0"> {
                vm.metrics.SignatureFailures++
        }</span>
}

// RecordBackupMetrics records metrics for backup operations
func (vm *VersionManager) RecordBackupMetrics() <span class="cov0" title="0">{
        vm.metrics.BackupsCreated++

        // Count active backups
        activeCount := int64(0)
        for _, backup := range vm.backups </span><span class="cov0" title="0">{
                if backup.Status == "active" </span><span class="cov0" title="0">{
                        activeCount++
                }</span>
        }
        <span class="cov0" title="0">vm.metrics.BackupsActive = activeCount</span>
}

// GetHealthStatus returns overall health status of version management
func (vm *VersionManager) GetHealthStatus() map[string]interface{} <span class="cov1" title="1">{
        now := time.Now()
        driftCheckAge := now.Sub(vm.metrics.LastDriftCheck)

        // Calculate health score (0-100)
        healthScore := 100.0

        // Penalize for outdated workers
        if vm.metrics.WorkersChecked &gt; 0 </span><span class="cov0" title="0">{
                outdatedRatio := float64(vm.metrics.WorkersOutdated) / float64(vm.metrics.WorkersChecked)
                healthScore -= outdatedRatio * 50
        }</span>

        // Penalize for unhealthy workers
        <span class="cov1" title="1">if vm.metrics.WorkersChecked &gt; 0 </span><span class="cov0" title="0">{
                unhealthyRatio := float64(vm.metrics.WorkersUnhealthy) / float64(vm.metrics.WorkersChecked)
                healthScore -= unhealthyRatio * 30
        }</span>

        // Penalize for old drift checks
        <span class="cov1" title="1">if driftCheckAge &gt; time.Hour </span><span class="cov1" title="1">{
                agePenalty := float64(driftCheckAge/time.Hour) * 5
                if agePenalty &gt; 20 </span><span class="cov1" title="1">{
                        agePenalty = 20
                }</span>
                <span class="cov1" title="1">healthScore -= agePenalty</span>
        }

        // Penalize for update failures
        <span class="cov1" title="1">if vm.metrics.TotalUpdates &gt; 0 </span><span class="cov0" title="0">{
                failureRatio := float64(vm.metrics.FailedUpdates) / float64(vm.metrics.TotalUpdates)
                healthScore -= failureRatio * 10
        }</span>

        <span class="cov1" title="1">if healthScore &lt; 0 </span><span class="cov0" title="0">{
                healthScore = 0
        }</span>

        <span class="cov1" title="1">status := "healthy"
        if healthScore &lt; 70 </span><span class="cov0" title="0">{
                status = "warning"
        }</span>
        <span class="cov1" title="1">if healthScore &lt; 40 </span><span class="cov0" title="0">{
                status = "critical"
        }</span>

        <span class="cov1" title="1">return map[string]interface{}{
                "status":                status,
                "health_score":          healthScore,
                "last_drift_check":      vm.metrics.LastDriftCheck,
                "drift_check_age":       driftCheckAge,
                "workers_checked":       vm.metrics.WorkersChecked,
                "workers_up_to_date":    vm.metrics.WorkersUpToDate,
                "workers_outdated":      vm.metrics.WorkersOutdated,
                "workers_unhealthy":     vm.metrics.WorkersUnhealthy,
                "active_alerts":         len(vm.alerts),
                "update_success_rate":   vm.calculateSuccessRate(vm.metrics.SuccessfulUpdates, vm.metrics.TotalUpdates),
                "rollback_success_rate": vm.calculateSuccessRate(vm.metrics.SuccessfulRollbacks, vm.metrics.TotalRollbacks),
        }</span>
}

// calculateSuccessRate calculates success rate as percentage
func (vm *VersionManager) calculateSuccessRate(successes, total int64) float64 <span class="cov2" title="2">{
        if total == 0 </span><span class="cov2" title="2">{
                return 100.0
        }</span>
        <span class="cov0" title="0">return float64(successes) / float64(total) * 100.0</span>
}

// signUpdatePackage creates a digital signature for an update package
func (vm *VersionManager) signUpdatePackage(packagePath, privateKeyPath string) (string, error) <span class="cov0" title="0">{
        // Read the private key
        keyData, err := os.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read private key: %w", err)
        }</span>

        // Parse the private key
        <span class="cov0" title="0">block, _ := pem.Decode(keyData)
        if block == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode PEM block")
        }</span>

        <span class="cov0" title="0">privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse private key: %w", err)
        }</span>

        // Read the package file
        <span class="cov0" title="0">packageData, err := os.ReadFile(packagePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read package file: %w", err)
        }</span>

        // Create hash of the package
        <span class="cov0" title="0">hash := sha256.Sum256(packageData)

        // Sign the hash
        signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign package: %w", err)
        }</span>

        // Create signature file path
        <span class="cov0" title="0">sigPath := packagePath + ".sig"

        // Write signature to file
        if err := os.WriteFile(sigPath, signature, 0644); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write signature file: %w", err)
        }</span>

        <span class="cov0" title="0">return sigPath, nil</span>
}

// verifyUpdatePackage verifies the digital signature of an update package
func (vm *VersionManager) verifyUpdatePackage(packagePath, signaturePath, publicKeyPath string) error <span class="cov0" title="0">{
        // Read the public key
        keyData, err := os.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read public key: %w", err)
        }</span>

        // Parse the public key
        <span class="cov0" title="0">block, _ := pem.Decode(keyData)
        if block == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode PEM block")
        }</span>

        <span class="cov0" title="0">publicKey, err := x509.ParsePKCS1PublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        // Read the package file
        <span class="cov0" title="0">packageData, err := os.ReadFile(packagePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read package file: %w", err)
        }</span>

        // Read the signature
        <span class="cov0" title="0">signature, err := os.ReadFile(signaturePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read signature file: %w", err)
        }</span>

        // Create hash of the package
        <span class="cov0" title="0">hash := sha256.Sum256(packageData)

        // Verify the signature
        err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], signature)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("signature verification failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateSigningKeys generates a new RSA key pair for signing
func (vm *VersionManager) generateSigningKeys(keyDir string) (privateKeyPath, publicKeyPath string, err error) <span class="cov0" title="0">{
        // Ensure key directory exists
        if err := os.MkdirAll(keyDir, 0700); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to create key directory: %w", err)
        }</span>

        // Generate private key
        <span class="cov0" title="0">privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        // Encode private key to PEM
        <span class="cov0" title="0">privateKeyPEM := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        }

        privateKeyPath = filepath.Join(keyDir, "translator-signing-key.pem")
        privateFile, err := os.OpenFile(privateKeyPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to create private key file: %w", err)
        }</span>
        <span class="cov0" title="0">defer privateFile.Close()

        if err := pem.Encode(privateFile, privateKeyPEM); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to encode private key: %w", err)
        }</span>

        // Encode public key to PEM
        <span class="cov0" title="0">publicKeyPEM := &amp;pem.Block{
                Type:  "RSA PUBLIC KEY",
                Bytes: x509.MarshalPKCS1PublicKey(&amp;privateKey.PublicKey),
        }

        publicKeyPath = filepath.Join(keyDir, "translator-signing-key.pub")
        publicFile, err := os.OpenFile(publicKeyPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to create public key file: %w", err)
        }</span>
        <span class="cov0" title="0">defer publicFile.Close()

        if err := pem.Encode(publicFile, publicKeyPEM); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to encode public key: %w", err)
        }</span>

        <span class="cov0" title="0">return privateKeyPath, publicKeyPath, nil</span>
}

// createSignedUpdatePackage creates and signs an update package
func (vm *VersionManager) createSignedUpdatePackage(privateKeyPath string) (*SignedUpdatePackage, error) <span class="cov0" title="0">{
        // Create the update package
        packagePath, err := vm.createUpdatePackage()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create update package: %w", err)
        }</span>

        // Sign the package
        <span class="cov0" title="0">signaturePath, err := vm.signUpdatePackage(packagePath, privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                os.Remove(packagePath) // Clean up on failure
                return nil, fmt.Errorf("failed to sign update package: %w", err)
        }</span>

        // Get public key path (assume it's alongside private key)
        <span class="cov0" title="0">publicKeyPath := strings.TrimSuffix(privateKeyPath, ".pem") + ".pub"

        signedPackage := &amp;SignedUpdatePackage{
                PackagePath:   packagePath,
                SignaturePath: signaturePath,
                PublicKeyPath: publicKeyPath,
                Version:       vm.localVersion.CodebaseVersion,
                Timestamp:     time.Now(),
        }

        return signedPackage, nil</span>
}

// uploadSignatureFiles uploads signature and public key files to the worker
func (vm *VersionManager) uploadSignatureFiles(ctx context.Context, service *RemoteService, signedPackage *SignedUpdatePackage) error <span class="cov0" title="0">{
        // Upload signature file
        if err := vm.uploadFileToWorker(ctx, service, signedPackage.SignaturePath, "signature"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload signature file: %w", err)
        }</span>

        // Upload public key file
        <span class="cov0" title="0">if err := vm.uploadFileToWorker(ctx, service, signedPackage.PublicKeyPath, "public_key"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload public key file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// uploadFileToWorker uploads a file to the worker with a specific type
func (vm *VersionManager) uploadFileToWorker(ctx context.Context, service *RemoteService, filePath, fileType string) error <span class="cov0" title="0">{
        var uploadURL string
        if vm.baseURL != "" </span><span class="cov0" title="0">{
                uploadURL = fmt.Sprintf("%s/api/v1/update/upload/%s", vm.baseURL, fileType)
        }</span> else<span class="cov0" title="0"> {
                uploadURL = fmt.Sprintf("%s://%s:%d/api/v1/update/upload/%s", service.Protocol, service.Host, service.Port, fileType)
        }</span>

        <span class="cov0" title="0">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open file %s: %w", filePath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        req, err := http.NewRequestWithContext(ctx, "POST", uploadURL, file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create upload request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/octet-stream")
        req.Header.Set("X-File-Type", fileType)
        req.Header.Set("X-Update-Version", vm.localVersion.CodebaseVersion)

        resp, err := vm.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("file upload failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
