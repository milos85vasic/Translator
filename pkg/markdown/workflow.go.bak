package markdown

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"digital.vasic.translator/pkg/ebook"
	"digital.vasic.translator/pkg/translator"
	"digital.vasic.translator/pkg/translator/llm"
)

// MarkdownWorkflow handles the ebook → markdown → translation → ebook workflow
type MarkdownWorkflow struct {
	translator    translator.Translator
	llmProvider   translator.Translator
	tempDir       string
	progress      ProgressCallback
}

// ProgressCallback reports workflow progress
type ProgressCallback func(stage string, progress float64, message string)

// NewMarkdownWorkflow creates a new markdown-based translation workflow
func NewMarkdownWorkflow(llmProvider translator.Translator) *MarkdownWorkflow {
	return &MarkdownWorkflow{
		translator:    ebook.NewUniversalParser(),
		llmProvider:   llmProvider,
		tempDir:       os.TempDir(),
	}
}

// SetProgressCallback sets the progress callback
func (mw *MarkdownWorkflow) SetProgressCallback(callback ProgressCallback) {
	mw.progress = callback
}

// reportProgress reports progress if callback is set
func (mw *MarkdownWorkflow) reportProgress(stage string, progress float64, message string) {
	if mw.progress != nil {
		mw.progress(stage, progress, message)
	}
}

// TranslateEbook performs the complete ebook → markdown → translation → ebook workflow
func (mw *MarkdownWorkflow) TranslateEbook(ctx context.Context, inputPath, outputPath, sourceLang, targetLang string) error {
	mw.reportProgress("start", 0.0, "Starting translation workflow")
	
	// Step 1: Parse source ebook
	mw.reportProgress("parse", 0.1, "Parsing source ebook")
	book, err := mw.translator.Parse(inputPath)
	if err != nil {
		return fmt.Errorf("failed to parse source ebook: %w", err)
	}
	
	// Step 2: Convert to markdown
	mw.reportProgress("convert", 0.2, "Converting to markdown")
	originalMarkdown, err := mw.convertEbookToMarkdown(book)
	if err != nil {
		return fmt.Errorf("failed to convert ebook to markdown: %w", err)
	}
	
	// Save original markdown
	originalMarkdownPath := filepath.Join(filepath.Dir(inputPath), 
		fmt.Sprintf("%s_original.md", strings.TrimSuffix(filepath.Base(inputPath), filepath.Ext(inputPath))))
	if err := os.WriteFile(originalMarkdownPath, []byte(originalMarkdown), 0644); err != nil {
		return fmt.Errorf("failed to save original markdown: %w", err)
	}
	
	// Step 3: Translate markdown
	mw.reportProgress("translate", 0.3, "Translating markdown content")
	translatedMarkdown, err := mw.translateMarkdown(ctx, originalMarkdown, sourceLang, targetLang)
	if err != nil {
		return fmt.Errorf("failed to translate markdown: %w", err)
	}
	
	// Save translated markdown
	translatedMarkdownPath := filepath.Join(filepath.Dir(inputPath), 
		fmt.Sprintf("%s_translated.md", strings.TrimSuffix(filepath.Base(inputPath), filepath.Ext(inputPath))))
	if err := os.WriteFile(translatedMarkdownPath, []byte(translatedMarkdown), 0644); err != nil {
		return fmt.Errorf("failed to save translated markdown: %w", err)
	}
	
	// Step 4: Convert translated markdown back to ebook
	mw.reportProgress("rebuild", 0.8, "Converting translated markdown to ebook")
	if err := mw.convertMarkdownToEbook(translatedMarkdown, outputPath, targetLang); err != nil {
		return fmt.Errorf("failed to convert markdown to ebook: %w", err)
	}
	
	mw.reportProgress("complete", 1.0, "Translation workflow completed")
	return nil
}

// convertEbookToMarkdown converts an ebook to markdown format
func (mw *MarkdownWorkflow) convertEbookToMarkdown(book *ebook.Book) (string, error) {
	var markdown strings.Builder
	
	// Add metadata
	markdown.WriteString(fmt.Sprintf("# %s\n\n", book.Metadata.Title))
	
	if len(book.Metadata.Authors) > 0 {
		markdown.WriteString("**Authors:** ")
		for i, author := range book.Metadata.Authors {
			if i > 0 {
				markdown.WriteString(", ")
			}
			markdown.WriteString(fmt.Sprintf("%s %s", author.FirstName, author.LastName))
		}
		markdown.WriteString("\n\n")
	}
	
	if book.Metadata.Description != "" {
		markdown.WriteString(fmt.Sprintf("**Description:** %s\n\n", book.Metadata.Description))
	}
	
	markdown.WriteString("---\n\n")
	
	// Add content
	for i, chapter := range book.Chapters {
		if chapter.Title != "" {
			markdown.WriteString(fmt.Sprintf("## Chapter %d: %s\n\n", i+1, chapter.Title))
		} else {
			markdown.WriteString(fmt.Sprintf("## Chapter %d\n\n", i+1))
		}
		
		// Convert chapter content to markdown
		markdown.WriteString(mw.convertTextToMarkdown(chapter.Content))
		markdown.WriteString("\n\n")
	}
	
	return markdown.String(), nil
}

// convertTextToMarkdown converts text content to markdown format
func (mw *MarkdownWorkflow) convertTextToMarkdown(text string) string {
	// Clean up the text and add basic markdown formatting
	text = strings.TrimSpace(text)
	
	// Replace multiple newlines with single newlines
	re := regexp.MustCompile(`\n\s*\n\s*\n`)
	text = re.ReplaceAllString(text, "\n\n")
	
	// Basic text cleanup
	text = strings.ReplaceAll(text, "\t", "  ")
	
	return text
}

// translateMarkdown translates markdown content while preserving formatting
func (mw *MarkdownWorkflow) translateMarkdown(ctx context.Context, markdown, sourceLang, targetLang string) (string, error) {
	// Split markdown into chunks for translation
	chunks := mw.splitMarkdownIntoChunks(markdown)
	
	var translated strings.Builder
	totalChunks := len(chunks)
	
	for i, chunk := range chunks {
		progress := float64(i) / float64(totalChunks) * 0.5 + 0.3 // 30-80% progress
		mw.reportProgress("translate", progress, fmt.Sprintf("Translating chunk %d/%d", i+1, totalChunks))
		
		// Skip empty chunks
		if strings.TrimSpace(chunk) == "" {
			translated.WriteString(chunk)
			continue
		}
		
		// Create translation request
		req := translator.TranslationRequest{
			SourceLang: sourceLang,
			TargetLang: targetLang,
			Text:       chunk,
		}
		
		// Translate chunk
		resp, err := mw.llmProvider.Translate(ctx, req)
		if err != nil {
			return "", fmt.Errorf("failed to translate chunk %d: %w", i+1, err)
		}
		
		translated.WriteString(resp.TargetText)
	}
	
	return translated.String(), nil
}

// splitMarkdownIntoChunks splits markdown content into manageable chunks
func (mw *MarkdownWorkflow) splitMarkdownIntoChunks(markdown string) []string {
	var chunks []string
	scanner := bufio.NewScanner(strings.NewReader(markdown))
	
	var currentChunk strings.Builder
	maxChunkSize := 3000 // Target around 3k characters per chunk
	
	for scanner.Scan() {
		line := scanner.Text()
		
		// If adding this line would exceed chunk size and we have content, start new chunk
		if currentChunk.Len()+len(line) > maxChunkSize && currentChunk.Len() > 0 {
			// Try to break at logical boundaries (headers, paragraphs)
			if strings.HasPrefix(line, "#") || strings.TrimSpace(line) == "" {
				chunks = append(chunks, currentChunk.String())
				currentChunk.Reset()
			}
		}
		
		currentChunk.WriteString(line)
		currentChunk.WriteString("\n")
	}
	
	// Add the last chunk if there's content
	if currentChunk.Len() > 0 {
		chunks = append(chunks, currentChunk.String())
	}
	
	// If we have too many small chunks, merge some
	if len(chunks) > 50 {
		chunks = mw.mergeSmallChunks(chunks)
	}
	
	return chunks
}

// mergeSmallChunks merges small chunks to reduce translation overhead
func (mw *MarkdownWorkflow) mergeSmallChunks(chunks []string) []string {
	var merged []string
	var current strings.Builder
	
	for _, chunk := range chunks {
		// If current chunk is small, add to it
		if current.Len() < 1000 {
			current.WriteString(chunk)
			current.WriteString("\n")
		} else {
			// Save current chunk and start new one
			if current.Len() > 0 {
				merged = append(merged, current.String())
				current.Reset()
			}
			current.WriteString(chunk)
		}
	}
	
	// Add the last chunk
	if current.Len() > 0 {
		merged = append(merged, current.String())
	}
	
	return merged
}

// convertMarkdownToEbook converts markdown content to ebook format
func (mw *MarkdownWorkflow) convertMarkdownToEbook(markdown, outputPath, targetLang string) error {
	// Parse markdown content
	book, err := mw.parseMarkdownToEbook(markdown, targetLang)
	if err != nil {
		return fmt.Errorf("failed to parse markdown to ebook: %w", err)
	}
	
	// Determine output format from extension
	ext := strings.ToLower(filepath.Ext(outputPath))
	if ext == "" {
		ext = ".epub" // Default to EPUB
	}
	
	// Create appropriate writer
	var writer ebook.Writer
	switch ext {
	case ".epub":
		writer = ebook.NewEPUBWriter()
	case ".fb2":
		writer = ebook.NewFB2Writer()
	default:
		return fmt.Errorf("unsupported output format: %s", ext)
	}
	
	// Write ebook
	return writer.Write(book, outputPath)
}

// parseMarkdownToEbook parses markdown content and converts to ebook format
func (mw *MarkdownWorkflow) parseMarkdownToEbook(markdown, targetLang string) (*ebook.Book, error) {
	book := &ebook.Book{
		Metadata: ebook.Metadata{
			Language: targetLang,
		},
		Chapters: []ebook.Chapter{},
	}
	
	scanner := bufio.NewScanner(strings.NewReader(markdown))
	var currentChapter *ebook.Chapter
	var chapterContent strings.Builder
	chapterIndex := 0
	
	for scanner.Scan() {
		line := scanner.Text()
		
		// Check for chapter headers
		if strings.HasPrefix(line, "## ") {
			// Save previous chapter if exists
			if currentChapter != nil {
				currentChapter.Content = chapterContent.String()
				book.Chapters = append(book.Chapters, *currentChapter)
			}
			
			// Start new chapter
			chapterIndex++
			title := strings.TrimSpace(strings.TrimPrefix(line, "## "))
			currentChapter = &ebook.Chapter{
				Title:   title,
				Content: "",
			}
			chapterContent.Reset()
		} else if strings.HasPrefix(line, "# ") && chapterIndex == 0 {
			// First line is the book title
			book.Metadata.Title = strings.TrimSpace(strings.TrimPrefix(line, "# "))
		} else if strings.HasPrefix(line, "**Authors:** ") {
			// Parse authors
			authorsLine := strings.TrimSpace(strings.TrimPrefix(line, "**Authors:** "))
			authors := strings.Split(authorsLine, ",")
			for _, author := range authors {
				author = strings.TrimSpace(author)
				if author != "" {
					parts := strings.Fields(author)
					if len(parts) >= 2 {
						book.Metadata.Authors = append(book.Metadata.Authors, ebook.Author{
							FirstName: strings.Join(parts[:len(parts)-1], " "),
							LastName:  parts[len(parts)-1],
						})
					} else {
						book.Metadata.Authors = append(book.Metadata.Authors, ebook.Author{
							FirstName: author,
							LastName:  "",
						})
					}
				}
			}
		} else {
			// Add to chapter content
			chapterContent.WriteString(line)
			chapterContent.WriteString("\n")
		}
	}
	
	// Add the last chapter
	if currentChapter != nil {
		currentChapter.Content = chapterContent.String()
		book.Chapters = append(book.Chapters, *currentChapter)
	}
	
	// If no chapters were found, treat the entire content as one chapter
	if len(book.Chapters) == 0 {
		book.Chapters = []ebook.Chapter{
			{
				Title:   "Main Content",
				Content: markdown,
			},
		}
	}
	
	return book, nil
}

// GetWorkflowSummary returns a summary of the translation workflow
func (mw *MarkdownWorkflow) GetWorkflowSummary(inputPath, outputPath string) *WorkflowSummary {
	return &WorkflowSummary{
		InputPath:      inputPath,
		OutputPath:     outputPath,
		Stages:         []string{"Parse", "Convert to Markdown", "Translate", "Rebuild Ebook"},
		StartTime:      time.Now(),
	}
}

// WorkflowSummary contains information about the translation workflow
type WorkflowSummary struct {
	InputPath   string       `json:"input_path"`
	OutputPath  string       `json:"output_path"`
	Stages      []string     `json:"stages"`
	StartTime   time.Time    `json:"start_time"`
	EndTime     time.Time    `json:"end_time,omitempty"`
	Duration    time.Duration `json:"duration,omitempty"`
	Success     bool         `json:"success,omitempty"`
	Error       string       `json:"error,omitempty"`
}

// Complete marks the workflow as completed
func (ws *WorkflowSummary) Complete(success bool, err error) {
	ws.EndTime = time.Now()
	ws.Duration = ws.EndTime.Sub(ws.StartTime)
	ws.Success = success
	if err != nil {
		ws.Error = err.Error()
	}
}