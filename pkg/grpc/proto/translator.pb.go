// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.31.0
// 	protoc        v4.25.0
// source: translator.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ProviderStatus represents the status of a translation provider
type ProviderStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Available     bool                  `protobuf:"varint,1,opt,name=available,proto3" json:"available,omitempty"`
	StatusMessage string                `protobuf:"bytes,2,opt,name=status_message,json=statusMessage,proto3" json:"status_message,omitempty"`
	ResponseTimeMs int32                 `protobuf:"varint,3,opt,name=response_time_ms,json=responseTimeMs,proto3" json:"response_time_ms,omitempty"`
	LastChecked   *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=last_checked,json=lastChecked,proto3" json:"last_checked,omitempty"`
}

func (x *ProviderStatus) Reset() {
	*x = ProviderStatus{}
	mi := &file_translator_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(x)
	ms.StoreMessageInfo(mi)
}

func (x *ProviderStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProviderStatus) ProtoMessage() {}

func (x *ProviderStatus) ProtoReflect() protoreflect.Message {
	mi := &file_translator_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(x)
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ProviderStatus) GetAvailable() bool {
	if x != nil {
		return x.Available
	}
	return false
}

func (x *ProviderStatus) GetStatusMessage() string {
	if x != nil {
		return x.StatusMessage
	}
	return ""
}

func (x *ProviderStatus) GetResponseTimeMs() int32 {
	if x != nil {
		return x.ResponseTimeMs
	}
	return 0
}

func (x *ProviderStatus) GetLastChecked() *timestamppb.Timestamp {
	if x != nil {
		return x.LastChecked
	}
	return nil
}

// ProviderInfo contains information about a translation provider
type ProviderInfo struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	Name                string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                string                `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Description         string                `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	AvailableModels     []string              `protobuf:"bytes,4,rep,name=available_models,json=availableModels,proto3" json:"available_models,omitempty"`
	Capabilities        map[string]string     `protobuf:"bytes,5,rep,name=capabilities,proto3" json:"capabilities,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RequiresApiKey      bool                  `protobuf:"varint,6,opt,name=requires_api_key,json=requiresApiKey,proto3" json:"requires_api_key,omitempty"`
	RequiresSshConfig   bool                  `protobuf:"varint,7,opt,name=requires_ssh_config,json=requiresSshConfig,proto3" json:"requires_ssh_config,omitempty"`
	RequiresLocalBinary bool                  `protobuf:"varint,8,opt,name=requires_local_binary,json=requiresLocalBinary,proto3" json:"requires_local_binary,omitempty"`
	Status              *ProviderStatus       `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *ProviderInfo) Reset() {
	*x = ProviderInfo{}
	mi := &file_translator_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(x)
	ms.StoreMessageInfo(mi)
}

func (x *ProviderInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProviderInfo) ProtoMessage() {}

func (x *ProviderInfo) ProtoReflect() protoreflect.Message {
	mi := &file_translator_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(x)
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Simplified implementation for demonstration
// Full protobuf implementation would be much longer